2024-11-14
데이터 그룹화가 잘못되었을 때의 문제점
데이터 갱신에 문제가 생길 수 있다.
속성에 null이 들어있을 수 있다.
	-저장공간의 낭비
	-속성의 의미 모호
	-조인연산의 의미 모호*
	-집단함수의 의미 모호*
*나중에 설명

속성값이 null이 들어갈 수 있는 가짓수
	없다.
	모른다.
	해당사항이 없다.

null이 들어갈 수 있는 속성이 있다면
그룹화를 더 나눠서 null값이 나올 수 있는 속성을 빼준다.

릴레이션의 분해
하나의 그룹이 었던 속성을 두 그룹으로 나누는것
원래대로 복구 가능한 상태로 잘라야한다.

릴레이션 분해의 단점
원래대로 복구가 안될 수도 있다.
질의가 복잡해진다.

릴레이션의 Join
관련있는 튜플을 결합하여 하나의 튜플로 생성

무손실 분해
손실 분해
정보의 손실은 원래 릴레이션의 정보가 join했을 때 그대로가 아니라 
적거나 많은 경우를 모두 포함한다.***
이상한 정보가 추가되면 무엇이 정확한 정보인지 알 수 없어지기 때문에 이런 것도 정보의 손실이라고 한다.

잘못 그룹화된 릴레이션을 찾고
무손실 분해를 반복한다면 좋은 관계형 데이터가 만들어 질것이다.

2024-11-20
수정이상
삽입이상
	원하지 않은 부가적인 데이터를 삽입하게 되어서 발생하는 문제
	무손실 분해(분해한 것들을 합쳤을 때 원래대로 돌아가는가)를 통해서 해결
삭제이상
	원하는 데이터만 삭제하고 싶은데 원하지 않은 데이터까지 삭제되는 현상

속성 a가 b의 결정자이면 b는 a에 함수적으로 종속한다. = a -> b
결정자 : 어떤 a값을 넣었을 때 b값이 하나만 나올 때 결정자라고 할 수 있다.

키 속성은 릴레이션에 속하는 모든 속성에 대한 결정자 역할을 하는 속성이다.
우연히 어떠한 집합에 중복이 없다고 해서 키라고 정할 수는 없다.
키를 찾으려면 모든 속성에 대해 관계가 결정자 역할을 하는가 확인해봐야한다.

완전함수적 종속성 FFD
a,b가 모두 한 릴레이션의 속성 집합이다.
a->b
a의 어떠한 진부분 집합에도 b가 함수적으로 종속하지 않는다. = a속성을 구성하는 집합에서 어느 한 부분이라도 빠진다면 b가 종속하지 않는다.

부분함수적 종속성
a속성을 구성하는 집합에서 어느 한 부분이라도 빠져도 b가 종속한다.

이행적 함수적 종속성
a,b,c가 모두 한 릴레이션의 속성 집합이다.
a -> b, b -> c
a -> c
이행적으로 종속하면 직접적으로 종속한다.


암스트롱 추론규칙
x -> yz면 x -> y, x -> z이다. 
x -> y면 xz -> yz이다.
x -> y이고 y -> z이면 x -> z이다.
그 밖의 추론규칙
x -> yz >> x -> y, x -> z
x -> y, x -> z >> x -> yz
x -> y, wy -> z >> wx -> z

x -> y, x -> z >> x -> yz
xx -> xy
xy -> yz
xx -> yz
x -> yz

xw-> wwy
xw-> z
정규화
나쁜 릴레이션 스키마를 좋은 릴레이션 스키마로 만들기 위한 분해과정

2024-11-21
정규형 : 정규화를 만들기 위한 과정중에 만들어진 형태
제1 정규형 : 모든 속성이 원자 값만을 가진다.
		반복 그룹이 없다.
		다치 속성이 없다.
다치 속성은 하나의 스키마에 넣지 않고 다른 릴레이션을 하나 더 만들어서 사용하기 때문에 ER모델에서 만들었던것과 같이 만들면 된다.
키를 두개로 만들고 다치 속성의 레코드를 더 만든다.

제2 정규형 : 제1 정규형을 만족한다.
		기본키에 속하지 않는 모든 속성들이 기본키에 완전하게 함수적으로 종속해야한다. 부분종속성이 존재하지 않는다.
		기본키가 하나만 있다면 완전하게 종속되어있기 때문에 부분 종속성을 따지지 않는다.
학번 학과이름 학과번호
학과이름과 학과번호 사이에 이행적 종속성이 성립한다.

제3 정규형 : 제2 정규형을 만족한다.
		기본 키에 속하지 않는 모든 속성들이 기본키에 이행적으로 종속하지 않는다.

BCNF	:	제3 정규형을 만족한다.
		모든 결정자가 후보키이어야 한다.
		후보키가 아닌 키는 존재하지 않는 릴레이션

양쪽 릴레이션에 공동으로 들어가 있는 속성이 필요하다.
기본 키 외래 키 형태로 만들어야 해서 키가 두개 이상 들어간다.

엔티티무결성 제약조건에 의해서
기본 키속성은 null이 들어갈 수 없다.

정규화의 장점
중복이 감소 
갱신이상 감소
무결성 제약조건을 시행하기 위해 필요한 코드의 양도 감소됨

정규화의 단점
성능 저하

(a,b)
a->(a,d,e,i,j)
b->(b,f,g,h)
c->(c)
R1(a,d,e,i,j) R2(b,f,g,h) R3(a,b,c)
A,D,E / B,F / A,B,C / F,G,H / D,I,J

ab->ci
bd ->ef
ad->ghij
ab ad bd가 키

car#->date_sold->discount_amt
salesman->commission
car#, salesman이 키다.

booktitle -> publisher, booktype,listprice
authorname -> author_affil 

2024-11-27
질의어 - 관계대수
대수 -> 식 algebra
항 연산자
realation 여러개의 튜플들의 합
관계해석 => 원하는 데이터만 명시하고 질의를 어떻게 수행할 것인지는 명시하지 않는 선언적인 언어
		(수행방법에 대해서는 신경을 쓰지 않고 결과만 바라는 언어)

관계대수 => 선언적 언어이지만 약간의 절차성이 있다, sql의 이론적인 기초
		(절차적 언어 : 수행방법에 따라서 구체적인 설명을 한다.)

필수 연산자 -> 단항 연산자 이항 연산자
	단항 연산자
		셀렉션-원하는 튜플만 뽑아내는것(시그마의 형태) 시그마 조건문 (부서 소속)
		프로젝션-원하는 프로젝션만 뽑아내는것(파이 형태) 파이 리스트 (조건문)
		셀렉션과 프로젝션은 교환법칙이 가능하지만 항상 가능한게 아니다
pi empname salary(employee)
pi empname title salary(시그마salary>2700000(employee))
pi title(시그마empname = 조민희(EMPLOYEE))
	이항 연산자 
		합집합 U
		차집합 -
		곱집합 X /Cartesian product -> 행렬의 곱셈과 같은 형식으로 이루어진다. 

조인 연산 -> 카티션 프로덕트를 하고 셀렉션을 한 것
디비젼 연산 -> 나누기, 잘 안씀
집단 함수와 그룹화연산
외부조인과 외부 합집합

산술연산이 없다.
집단함수가 없다.
정렬이 없다.
갱신연산이 없다.
무조건적인 중복배제

이항연산자 호환성을 맞춰줘야한다.
스키마가 동일한 두 표에 대해서만 집합 연산이 가능하다.
합집합 연산은 항상 가능한게 아니고 각각의 집합이 다루고 있는 바가 같아야 합집합을 수행할 수 있다.
도메인 제약조건에서 모든 속성은 영역에 해당하는 속성만 가져야한다.

파이 DNO (시그마EMPNAME = 김창섭 OR EMPNAME = 최종철(EMPLOYEE)) 교집합 파이 시그마 DEPNAME = 기획(DEPARTMENT)
파이  DEPTNO (DEPARTMENT) 차집합 파이 DNO (EMPLOYEE)

관리를 위해서는 데이터가 분산되어 있지만 -> NULL이 발생하고 중복이 발생하는것을 막기위해서
내가 찾을 때는 CARTESIAN PRODUCT를 사용해서 데이터들을 합쳐서 찾아서 사용한다.
파이 ENAME(시그마 DNO = DEPNO(EMP 카티션프로덕트 DEPT))

파이 NAME, EMPNO(시그마 TITLE = 대리 AND SALARY >= 3000(EMP))
파이 DEPTNAME((시그마 NAME = 김영식(EMP)X DEPT))
유도된 연산자