2024-09-05------------------------------------------------------------------------------
용어를 중요시했다 외워야한다.

데이터 : 의미를 가지면서 기록될 수 있는 알려진 사실(상황에 따라 다른 의미를 가질 수 있고, 사람들은 계속해서 기록을 해왔다. 기록은 되고 있지만 그 **정보에 의미가 부여된다면 데이터가 된다**.)

데이터베이스 : 관련있는 데이터의 모임

데이터베이스 관리시스템 : 데이터베이스의 생성과 관리를 담당하는 //소프트웨어 패키지(search, insert, delete) //

데이터베이스 시스템 : 데이터베이스와 그를 관리하는 //소프트웨어 모두를 칭하는 용어//

작은 세계 : 데이터베이스 구축의 대상이 되는 실세계의 일부분(

문서 데이터 베이스
-멀티미디어DB
-GIS 지리정보시스템
-Data Warehouse 데이터 창고
	데이터 마이닝 - 데이터 창고에서 필요없었던 데이터에서 서로 연관성이 발견하여 연결지어 데이터로 만든다.
-실시간 DB 데이터의 정확도 보다 근사치의 결과로 빠르게 결정을 내릴 수 있는 방법 추구
-빅데이터 여러가지의 비정형화된 데이터를 나타낸다.

2024-09-11------------------------------------------------------------------------------
그림의 제목을 먼저 봐라
설명이 먼저 있고 그림이 나와야 한다.
우리가 사는틀이 정해져 있기 때문에 없던것에 대하여 불편해 하지 않는다.
저장된 데이터 베이스 = 데이터 베이스

데이터
: 의미를 가지면서 기록될 수 있는 알려진 사실
데이터베이스
: 관련있는 데이터의 모임
데이터베이스 관리시스템
: 데이터베이스 생성과 관리를 담당하는 소프트웨어
: 질의어와 프로그램을 처리하는 소프트웨어
: 저장된 데이터에 접근하는 소프트웨어
데이터베이스 시스템
: 데이터베이스를 관리하는 소프트웨어 모두를 칭하는 용어

메타인지가 다되었다고 생각한다. -> 자기자신을 아는것이래
다 맞았다면 내가 이 내용들을 다 알고 있었다는 것을 다시 알게 되니까. 몰랐던 부분을 알게되려면 검증이 필요하다고 생각한다.
///////////////


메타데이터 : 데이터가 무엇인지를 설명하는 데이터 -> 데이터 베이스 일 수 도 있고 아닐수도 있다.
데이터에 대한 데이터 ex) 이 배열은 현재 정렬된 상태로 저장되어 있다.

Queries : 질의어 -> 내가 질문으로 얻어내고자 하는게 있어서 하는말
데이터 베이스에서 사용되는 질의어 -> SQL

시스템 카탈로그 = 메타데이터

DBMS는 운영체제를 통해서 하드웨어에 접근하는 방식과
하드웨어에 바로 접근하는 방식이 있다.


파일 시스템 -> 소프트웨어
운영체제에서 관리하는 소프트웨어로 데이터베이스와는 구별되는 기능이다.

	데이터 파일이기 위한 조건
물리적인 비트의 연속
순차적인 레코드들로 구성
레코드는 연관된 필드들의 모임

레코드 -> 일정한 규칙을 가지고 연관된 필드들로 모여져 있는것

데이터에 대한 프로그램의 의존도가 높다.
데이터의 구조가 바뀌면 프로그램이 바뀌어야 한다.
새로 업데이트 되어야 하는게 의존도가 높다고 한다.

데이터의 중복성**
저장공간이 낭비되고 
컴퓨터가 작업을 할 때는 동시에 한다는 게 없기 때문에 한가지의 데이터로 묶어서 사용해야한다. -> 데이터가 중복되면 안된다. 
같은 내용의 데이터이지만 어디에서는 수정되고 안되는곳이 생기는 문제 때문에 데이터의 불일치성이 문제가 된다.

	
	기본적으로 탑재 되어있는 기능들이다.
	파일시스템과 데이터베이스와의 차이점
데이터 모델링 개념
	데이터를 어떤식으로 구조화 할것인지 만들어보는것
	연관성을 표시 할 수 있고 이런식으로 데이터를 모아놓은 것이구나 하고 이해 할 수 있다.
질의어
	SQL
동시성제어
	동시에 같은 데이터에 접근해서 데이터가 깨질 수 있다.
파손, 회복
	파손되지 않도록 노력해준다.
보안

2024-09-12----------------------------------------------------------------------------
데이터 : 의미를 가지면서 기록될 수 있는 알려진 사실
데이타베이스 : 관련있는 데이터들의 모임
데이터베이스 관리시스템 : 데이터베이스 생성과 관리를 담당하는 소프트웨어 패키지
데이터베이스 시스템 : 데이터베이스와 그를 관리하는 소프트웨어 모두를 칭하는 용어

데이터 : 의미를 가지고 기록될 수 있는 알려진 사실
데이터 베이스 : 관련있는 데이터의 모임
데이터베이스관리 시스템 : 데이터베이스를 생성하고 관리하는 소프트웨어 패키지
데이터베이스 시스템 : 데이터베이스를 관리하는 소프트웨어 모두를 칭하는 용어

파일 처리 시스템 보다 데이터베이스의 장점
데이터의 중복성 처리
저장공간이 낭비되는걸 막을 수 있다.

파일 처리시스템
연속된 레코드들의 모임
레코드는 필드들로 구성되어 있다.
필드의 개수는 동일하다.
필드의 크기는 고정


데이터의 양과 메모리의 양은 비례한다. 그래서 공간복잡도를 생각할 때 메모리를 고려한다.

랜덤 액세스 : 임의의 위치에 있는데이터를 바로 엑세스 할 수 있는가
저장된 위치에 따라서 시간이 더 걸릴수도 있다.
하드디스크에는 원판이 있다.


배열이 가진 문제는 해결될 수 있지만 연결리스트로 만들었을 때 하나씩 디스크에 있는 레코드에서 엑세스 해야하는 문제가 있다.
디스크에 저장될 때 4개의 디스크에 나뉘어서 들어간다.
배열은 물리적으로 일정하게 떨어지게 저장을 해도 된다.
트랙과 실린더 

메모리에서 접근할 때는 금방 하기 때문에 정확하게 필요한 데이터만 가져오고
하드디스크에서는 오래 걸리기 때문에 한개씩 가져오는거 보다 한번에 여러개 가져오는게 빠르다. -> 버퍼의 의미

데이터 파일의 구조
데이터 파일의 데이터에 어떻게 빠르게 접근할 수 있을까.

리스트를 쓰면서 배열의 문제점이 해결되는가
연결리스트의 기본적인 문제가 디스크에서도 발견되는가
하드디스크에서 새로 부각되는 문제점이 있는가

메모리에서는 원하는 위치로 접근하는게 빨라서 포인터로 어디로 가던지 괜찮았는데 디스크는 직접 돌려야하니까 문제가 될것이다
포인터와 포인터로 연결되어 있으니까 연결리스트의 만의 문제는 해결되지 않았다.

하드디스크에서는 하나 하나씩 읽으려 하지 않고 뭉텅이로 들고오는데 연결리스트의 다음 포인터가 있는곳이 안에 있을지 알 수 없다.



연결리스트와 배열의 단점을 보완하는 새로운 자료구조**

2024-09-25----------------------------------------------------------------------------
순서파일에서 검색방법
순차검색을 사용하기로 했다.
블럭이 연결리스트 형태로 이루어져 있어서 순차검색을 이용한다.
왜 이진검색으로 검색하지 않는가 -> 정렬되어 있어야하고 트리형태로 되어있어야 한다.

1안 가장 뒤에 넣는다
2안 가장 앞에 넣는다
3안 가장뒤에 넣지만 같은 값끼리 같은 블럭에 넣자
4안 중간에 새로운 블럭을 만들어서 집어넣자

데이터 삽입
앞에 저장되어 있던 데이터들을 분할해서 반씩 나눠 저장한다. split
디스크엑세스 횟수는 변함이 없기 때문에 시간적 문제로 고려하지 않는다.
데이터 삭제
삭제할 때 레코드에 남아있는 데이터가 적으면 낭비이기 때문에
뒤의 레코드에 있는 데이터 양과 비교해서 
a+b <= 100 합병
a+b > 100 재분배
해서 항상 레코드를 효율적으로 사용한다.


2024-09-26------------------------------------------------------------------------
인덱스(책에서 목차와 같은 느낌으로 화일에 대한 또 다른 접근경로이다.)
-레코드를 빠르게 찾을 수 있도록 도와주는 보조 화일(bit stream으로 이루어짐/여러개의 레코드가 연속적으로 있다./각각의 레코드들은 여러개의 필드로 이루어짐)

인덱스 엔트리의 구조 -> 키 값들, 레코드 주소
키 값의 첫번째 레코드를 가지고 있는 블럭의 주소값을 가진다.
블럭을 탐색 후 해당 키 값보다 큰 값이 있지 않았다면 다음 블럭의 주소를 (연결리스트 형태로 이루어져 있기 때문에)찾아서 더 탐색한다.

전부 순차 검색하는것 보다 인덱스를 사용해서 묶어서 검색을 하는 게 훨씬 빠르다.
인덱스를 저장하는 데이터도 블럭에 레코드의 형태로 저장 되기 때문에 인덱스도 순차검색을 해야한다.
블럭은 하드디스크에 있다.

			Remind
인덱스로 순차검색보다 빠르게 접근할 수 있게 되었다.

새로운 데이터를 삽입 할 때
인덱스로 동일한 종류의 데이터가 저장되어 있는 블록으로 가서 공간이 있다면 넣고 없다면
현재 블록의 데이터들을 분할해서 새로운 블록을 추가하고 빈공간에 추가한다.

데이터를 삭제할 때
데이터가 삭제되어 블럭에 남아있는 데이터가 효율적이지 않다면
뒤의 블록과 비교해서 합이 100%보다 작다면 합친다.
100%보다 크다면 재분배한다.


2024-10-02-----------------------------------------------------------------------
블럭의 크기 = 한번에 하드디스크에서 읽어올 수 있는 데이터 크기의 최댓값
인덱스 엔트리(포인터)의 크기가 레코드의 데이터 값보다 작아서 같은 블럭이지만 더 많은 양의 인덱스 포인터를 저장할 수 도 있을 것이다.

그래서 인덱스 파일을 순차검색하는 게 더 빠를 것이다.

3.5를 가리키는 인덱스가 없다면 3.5를 찾고자 할 때 3인덱스에 얼마나 많은 데이터가 있을지 모르기 때문에 문제가 발생할 수 있다.
그리고 이전에 동작하던 인덱스파일에서 포인터를 찾아 데이터를 찾던 구조가 무너진다.
인덱스 파일을 분할 할 필요는 없고 3과 4사이에 추가로 생성해야한다고 생각한다.

특정값을 가진 레코드가 모두 삭제되었을 때 인덱스블럭에 있는 인덱스도 삭제를 해야하는가?

마지막에 있는 페이지에 그림 그리기


2024-10-03--------------------------------------------------------------------
	데이터베이스 설계
모든 주요 응용과 사용자들이 요구하는 데이터
데이터 간의 관계를 표현하는것

모든 데이터를 표현할 수 있다.
중복 최소화
효율적 접근
데이터 무결성
일관성 및 이해 용이


	DBMS
작은세계(우리가 실제로  데이터를 분석하고 사용하는 실세계의 영역)
요구사항 수집과 분석
데이터 베이스 요구사항들
1.  개념적 설계(ER모델)
	개념적  스키마
2. 논리적 설계
	논리적 스키마
3. 물리적 설계 - 성능을 고려해서 만드는 설계
	물리적 스키마

ER모델
실세계를 entity(독립적으로 존재하면서 고유하게 식별이 가능한 객체), attribute(엔티티를 구성하는 속성,학생의 이름, 학번과 같은 것)의 관계(수강, 소속 - 두개의 엔티티 사이를 연관짓는것)로 표현함
고도로 추상화 되어있다 - 인간이 생각하는것과 굉장히 유사하다
굉장히 강한 표현력
이해하는데 용이하다
 
attribute
entity의 구성요소
domain : 한 attribute가 가질수 있는 모든 값들의 집합 

3가지 카테고리에 따라서 6가지로 나뉜다.
단일 / 다치
단순 / 복합
유도된 / 저장된

	단순 속성
더 이상 다른 속성으로 나눌 수 없는 속성
ER다이어그램에서 실선 타원으로 표현함
대부분의 속성은 단순 속성

	복합 속성
두개 이상의 속성으로 이루어진 속성
동일한 개체 타입이나 관계 타입에 속하는 속성들 중에서 밀접하게 연관된 것을 모아놓은 것

	다치 속성
각 개체마다 여러 개의 값을 가질 수 있는 속성 -> 가명
ER 다이어그램에서 이중선 타원으로 표현함

	저장된 속성
다른 속성과 독립적으로 존재하는 속성
ER 다이어그램에서 실선 타원으로 표현함
대부분의 속성은 저장된 속성

	유도된 속성
다른 속성 값으로부터 얻어진 속성
ER 다이어그램에서 점선 타원으로 표현

	키 속성
한 객체 타입에서 각 객체가 유일한 값을 가지는 속성(딕셔너리)
키 속성은 복합 속성일 수도 있다.
개체 타입은 한개 이상의 키를 가질 수 있다.
ER 다이어그램에서 기본 키에 속하는 속성을 밑줄을 그어 표시함

2024-10-16-----------------------------------------------------------------------------------------
중복되지 않는 레코드로 이루어진 데이터 파일을 탐색하는 방법
인덱스 파일을 만들어 데이터 파일을 나타내는 포인터를 넣어놓고 

순서파일이면서 중복이 없는 데이터 파일을 어떻게 사용할 것인가
탐색 삽입 삭제 등
하나의 인덱스가 하나의 레코드 블럭을 담당하도록 만들자
빠지는 부분은 이어붙이면 되지
기본인덱스는 블럭의 첫번째 값을 가져와서 인덱스로 사용하는 인덱스다
블럭 마다 있는 첫번째 레코드를 인덱스로 사용해서 인덱스 파일을 만들고 사용한다
레코드를 삽입할 때 블럭을 추가하면 인덱스 파일에 새로운 인덱스를 추가 해준다.

인덱스를 추가해야한다고 생각한다. 
인덱스파일에 추가를 하지 않게 된다면 인덱스 파일에서 어느 블럭 사이에 있는가를 탐색하고 찾고자 하는 데이터가 있을 블럭으로 포인터를 타고 이동한 후 순차 검색을 하는데 없다면 없다고 생각하거나 다음블럭까지 탐색하는 알고리즘을 추가해줘야한다. 데이터 파일에가서 원래는 한 블럭안에 있는 데이터만 다 확인 하면 됬지만 추가하지 않는다면 한개 이상의 블럭을 검사해야해서 디스크 엑세스 횟수가 늘어나서 좋지 않다.

삭제
병합이 일어날 때
재분배가 일어날 때 
블록의 첫번째 레코드가 삭제될 때
어짜피 블록의 첫번째 레코드가 삭제되었더라도 기존의 레코드 보다 작은 데이터는 이전의 블록으로 갈것이고 보다 큰 데이터는 해당 블럭이나 뒤의 블록으로 갈 것이다.


인덱스의 종류
밀집 인덱스
데이터 화일내의 모든 탐색키 값(검색을 할 때 사용하는 필드의 값)에 대한 인덱스 엔트리를 정의
 - 인덱스 파일과 데이터 파일이 동일한 만큼 있는것 X
 - 중복이 있다면 개수가 다르기 때문에 위는 맞지 않다. 

희소인덱스
탐색값의 일부에 대해서만 인덱스 엔트리를 정의 

희소인덱스가 아무래도 인덱스 접근 횟수가 적을테니 희소인덱스로 만드는게 더 좋다
인덱스 파일의 크기가 작아서 인덱스 엔트리 횟수가 적으니 성능이 더 좋다.

*******************************************************************************************
파일의 크기  => 블럭의 개수 * 블럭의 크기
운영체제가 하드디스크의 성능을 기준으로 블럭의 크기를 정한다.

블록의 개수 = 레코드의 개수 / bf
bf(하나의 블록에 들어갈 수 있는 레코드의 최대 개수) = 블록의 크기 / 레코드의 크기
	
1 3개
2 10000블럭
3 16
4 32개
5 30000개
밀집인덱스를 사용한 접근 비용의 예

중복이 없다면 기본인덱스를 만드는게 성능이 좋다

2024-10-17------------------------------------------------------------------------------
순서파일에서 중복이 있다면 
같은 값을 갖는 레코드는 한 블럭에 넣어두고 싶다.
같은 종류의 값을 갖는 레코드를 한블럭에 최대한 넣어두고 싶다.

인덱스 레코드 하나당 데이터파일을 하나씩 만든건가
연결리스트의 형태로 블럭의 뒤에 같은값을 가지고 가는건가
클러스터링 인덱스라고 부른다.
해쉬테이블 
클러스터링 인덱스에서 리스트형태로 같은 데이터를 가진 블럭이 연결되어 있는데 어디에서 연결되어 있는가

중복된 데이터가 적다면 낭비되는 공간이 많을것이다.


현재 최소 데이터 레코드 보다 작은 데이터가 들어온다면 어디에 집어 넣어야하는가
2024-10-24----------------------------------------------------------------------------
개념적 설계
- ER모델 
- 어떠한 방식으로 우리가 표현하고자 하는 방식으로 표현하는가
논리적 설계
- ER모델만 잘 만들면 관계형 논리 모델로 쉽게 바꿀 수 있다.
물리적 설계
- 인덱스를 몇개를 만들것인가
- 데이터베이스 시스템이 알아서 최적화를 하고 사용자들을 이에 대해 잘 모른다.


ER모델
표현하기 쉽다.
이해하기 쉽다.
엔티티, 관계, 접근

대부분의 경우는 단순 단일 접근으로 처리하면 된다.
특정엔티티 타입을 나타내고 싶을 때 키 접근을 사용한다.
복합 접근 여러가지 접근을 같이 표현할 때
다치 접근 - 동그라미 두개
유도된 접근- 점선표현


엔티티 타입
강한 엔티티 타입
	대부분의 엔티티 타입
	독립적으로 존재
	독립적인 키 접근이 있다.
	실선 직사각형

약한 엔티티 타입
	아주 특별한 경우
	특정 강한 엔티티 타입에 종속되는 엔티티 타입 ex) 본인이 누군가의 자녀다 라고 알리는 것처럼 강한 엔티티 타입에 종속되게 나를 지칭하는 것
	독자적인 키 접근이 없다.
	두줄 실선 직사각형으로 표현
	정답이 없고 모델링을 하는 사람들이 사용할 수도 있고 사용하지 않을 수도 있다.
	
엔티티 타입과 엔티티 타입 사이에 생성되는 연관성


관계타입 : 동일한 의미를 가진 관계의 틀
여러개의 엔티티 타입 사이에 발견되는 연관성
카디날리티 제약조건 : 몇 대 몇의 관계를 갖는가
최대 카티 날리티
1 : 1, n : 1, 1 : n, n : m
n:m이 성립할 조건
1 : n이 성립하고
n : 1이 성립한다면
n : m도 성립한다.

최소 카디날리티 
0 : 선택적 참여
1이상 : 의무적 참여, 존재 종속  
의무적 참여는 간선을 두줄로 그어야 한다.

순환적 관계 타입
한개의 엔티티 타입이 어떤 관계타입에 서로 다른 역할로 중복참여한다.
동일한 엔티티 타입끼리도 관계타입이 적용될 수 있다.
명확하게 쓰기 위해서

내가 그린바가 내가 생각한 바를 제대로 표현하고 있는가?

한곳에 소속되어 있지만 다른 프로젝트에도 참여

entitiy타입(실선 사각형으로 그린다.)을 그리고 구성하는 attribute를 생각해 ㄹ
keyattribute를 찾아서 밑줄을 그려
entity사이의 관계를 그려
zip파일로 압축해ㅅㅓ 제출해라


관계형 데이터모델
relation : tuple의 집합
tuple : attribute의 나열
집합은 어떤순서로 정의가 되던 상관이 없다
tuple의 순서는 중요하지 않다.
중복된 원소들이 있다면 한개의 원소로 생각한다.
relation은 표의 형태로 데이터를 관리하는것이다.
표를 어떻게 효율적으로 관리해야 하는가를 보는게 관계형 데이터 모델

도메인 제약조건
키 제약조건
참조 무결성 제약조건
엔티티 무결성 제약조건

2024-10-30------------------------------------------------------------------
도메인 제약조건
참조 무결성 제약조건
키 제약조건
엔티티 무결성 제약조건
