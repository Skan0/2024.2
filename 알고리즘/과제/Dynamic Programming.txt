다이나믹 프로그래밍 DP
프로그래밍 대회에 자주 나오는 알고리즘이다.
동적 계획법이라고도 한다.
하나의 문제는 단 한번만 풀도록 하는 알고리즘이다
이미 구한 값은 저장해서 꺼내와서 사용하는 방법을 사용한다.
O(2^n) -> O(n)

분할정복 기법은 문제를 다시 푼다는 단점이 있다.
메모이제이션 : 구해둔 값을 저장해 두는것


플로이드 와샬 알고리즘
다익스트라 알고리즘에서 사용했던 방법과 비슷하지만 지나가는 정점을 반복문안에서
어떤것을 거쳐가는지 비교해서 갱신해주는 것
2 -> 3 vs  2 -> 1 -> 3

a -> b ? a -> k -> b 
2차원 테이블에 모든 점으로 이어지는 최단 거리 정보를 저장하고 점화식에 따라서 갱신한다.
O(n^3)의 알고리즘이기 때문에 시간이 중요한 문제라면 다른 알고리즘을 사용하는 게 좋겠다.


행렬 = 컴퓨터의 기본연산
행    열
가로 세로
행렬 간의 덧셈뺄셈이 가능하려면 같은 크기 이어야한다

곱셈과 나눗셈은 
앞에있는 행렬의 행과
뒤에있는 행렬의 열을 곱한다.
(axb) X (bxc)형태여야 곱하기가 가능하다.
뒤에 결과값은 (axc)의 형태이다
1 2 3		1 2	  1+6+15    2+8+18
4 5 6  X	3 4  =  4+15+30  8+20+36
		5 6


행렬
행렬을 곱할 때 어떤 행렬끼리 먼저 곱하는게 좋을까를 결정해야하는데 동적계획법으로 빠르게 나타낼 수 있다.


주어진 두개의 문자열에서 문자를 지우고 바꾸고 추가하는데 최소한의 횟수로 수행하라.

knapsack problem
2차원 테이블 dp[i][j]를 만들었다
i : 선택한 아이템의 개수
j : 현재 배낭 용량
dp[i][j]는 i개의 아이템 중 일부를 선택하여 무게가 j인 배낭에 담았을 때의 최대 가치를 저장한다.

아이템을 선택하지 않는 경우 dp[i][j] = dp[i−1][j] 선택한 아이템의 개수가 늘어나는데 
아이템을 선택하는 경우: 아이템의 무게가 현재 배낭 용량을 초과하지 않는다면 dp[i][j]=dp[i−1][j−wi]+vi
​

min coin change
sum을 만들어 줄 수 없다면 -1을 반환하면 된다.
F(11) = min(F(9),F(8),F(6)) +1
n개의 배열을 만들고 동전의 개수k만큼 확인 해야하기 때문에
O(k*n)의 시간이 걸린다.








