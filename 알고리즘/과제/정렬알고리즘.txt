동일한 시간복잡도를 가지고 있더라도 서로 더 빠르고 느린 알고리즘이 있다.
Bubble
사실 잘 사용되지는 않는다.
2개를 선택하고 왼쪽이 오른쪽보다 크면 서로 교환한다.
교환이 없을 때 까지 반복한다.
O(n^2)

selection
데이터들을 쭉 보면서 가장 작은 데이터를 저장
마지막까지 확인했다면 가장 작은 데이터를 가장 앞으로 가져오고
정렬된 부분과 정렬이 되지 않은 부분으로 나눈다.
후에 두번째로 작은 데이터를 가져와서 정렬되지 않은 부분의 가장 앞으로 가져온다.
O(n^2)

insertion
하나씩 오른쪽에 있는 데이터가 왼쪽에 있는 데이터보다 작다면 서로 바꾸고 한칸 왼쪽으로가서
바뀐 데이터와 바뀐 데이터의 왼쪽에 있는 데이터를 비교해서 왼쪽이 더 작다면 바꾸지 않는다.
삽입정렬은 필요한 데이터만 비교하기 때문에 위의 두 정렬보다 빠르다.
O(n^2)

shell
삽입정렬의 단점을 보완하기 위해서 나왔다.
갭을 두고 갭만큼 나눠두고 층마다 서로 삽입 정렬하고
갭을 더 줄여서 층마다 삽입 정렬하는 방법
O(n^2)


BinaryTree
자식이 두개 이하로만 붙을 수 있는 트리
Binary Search Tree
왼쪽의 노드는 오른쪽에있는 노드보다 작아야하고
왼쪽부터 순서에 맞게 빈공간 없이 채워져 있어야 한다.
FullBinaryTree
자식이 하나도 없거나 두개 다 있는 경우
PerfecttBinaryTree
양쪽으로 빈공간 없이 모두 두개의 자식을 가지고 레벨도 같은 경우
O(logn)

힙
최댓값이나 최솟값을 빠르게 찾기위해 완전 이진트리를 이용하는 알고리즘
최소힙
작은 값을 항상 트리 위에 놓도록 해서 가장 작은 값이 루트에 있다.
최대힙
큰 값이 항상 트리위에 놓도록 해서 가장 큰 값이 루트에 있다.

힙정렬에 추가하고 삭제하는 방법
트리에 추가하면 정렬이 되어있지 않기 때문에 부모노드와 크기를 비교한다.
루트에 있는 데이터를 Pop하면 
리프 노드를 루트에 넣고 정렬한다.
O(logn)

기수정렬
10의 자리 100의 자리와 같은 자릿수 별로 정렬하는 알고리즘
자릿수별로 정렬하고 다음자릿수 별로 정렬하고 하는식이다.
숫자로 하면 0~9까지만 정렬하면 되지만 알파벳의 경우 26자리까지 정렬해야 해서 적절하지 않다.
O(w*(n+k)) k는 가장 작은 데이터와 가장 큰 데이터의 차이 w는 k만큼 세는데 반복하는 횟수.

랜덤으로 놓여져 있는 데이터들을 Big-O 표기법에 시간 복잡도가 낮은 알고리즘들이 빨랐다.
근접하게 놓여진 데이터는 삽입정렬과 버블정렬이 빨랐다.
반대로 뒤집힌 데이터는 쉘정렬과 힙정렬이 빨랐다.
적은 종류의 중복된 데이터가 있는 것은 쉘정렬과 quick3정렬이 빨랐다.
모든 경우를 볼 때
쉘정렬 > 힙정렬 > 퀵정렬 순으로 빠르다.

어떤 데이터가 들어올지 모르기 때문에
평균적으로 빠른 알고리즘을 사용하는게 맞다는 생각이 들었다.

