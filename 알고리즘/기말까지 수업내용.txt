2024-10-25
그리디 알고리즘은 일단 한번 선택하면 이를 절대로 번복하지 않는다.
선택한 데이터를 버리고 다른것을 취하지 않는다.
이러한 특성 때문에 대부분의 그리디 알고리즘들은 매우 단순하며 또한 제한적인 문제만이 그리디 알고리즘으로 해결된다.

지수형태의 시간 복잡도 알고리즘을 가진 문제들을 너무 오래 걸리니까
그리디 알고리즘으로 근사값이라도 풀어보자 

동전 거스름돈 문제
남은 액수를 초과하지 않는 조건하에 욕심내어 가장 큰 액면의 동전을 취하는것

근시안적으로 해결가능한 문제만 풀 수 있다
160원짜리가 생기면 더이상 해결가능한 문제가 아니게 되어버린다.
항상 사용가능한 알고리즘이 아니라 특정 상황일 때만 사용가능하다.


최소신장트리 - MST
주어진 가중치 그래프에서 사이클 없이 모든 점을 연결 시킨 트리들중 가중치 합이 최소인 트리
트리는 사이클이 없어야 한다.
spanning 모든 점을 지나가는가
n개의 점이 있을 때 n-1개의 간선이 있다.
어느 한 선을 추가하면 반드시 사이클이 생긴다.


정점들이 간선들로 이어지고 있는 형태를 트리라고 한다.
점들이 서로 연결된 방향에 따라 어디에 연결되어 있는지 확인해도 좋지만 보통 A에서 B로 연결된것을 B에서 A로 연결되어있다고 A에도 저장하고 B에도 저장한다.

adjacency matrix 간선 한개로 연결되어 있는 값만 나타낸 행렬
아예 연결되어있지 않다면 무한대를 넣어도 좋다. 무한대로 넣으면 비교해서 간선을 선택하는 코드가 좀더 자연스럽게 흘러갈 수 있다.
none이나 null을 넣어도 좋지만 항상 체크를 해야한다.

adjacency list 연결된 정점들을 나타내는 리스트
set 상수시간의 시간복잡도가 걸린다.
시작점을 key값으로 하고 연결된 정점들을 value로 하는 dic로 나타내도 좋다.

저장은 list형태로 사용하고 표현은 matrix의 형태로 한다.

edgelist도 있다.

크러스컬 알고리즘
	가중치가 가장 적은 간선이 사이클을 만들지 않을 때에만 간선을 추가한다.
프림 알고리즘
	임의의 점 하나를 선택한후 n-1개의 간선을 하나씩 추가시켜 트리를 만든다.

2024-10-28
MST minimum spanning tree
spanning 모든간선을 연결한것

트리일수 있는 경우의 수에서 간선의 합이 가장 적은형태
크러스컬 - 지금당장 선택할 수 있는것을 선택한다. 가중치가 최소인 간선을 지나는데 이미 이어져 있다면 지나지 않는다. Union find -> 같은 루트를 가지고 있는가
프림 - 한점을 선정하고 이 점에서 다른 점으로의 간선중 최소인 점을 지나고 지나온 점을 포함해서 최소인 간선을 찾아서 또 연결하지만 이미 지난곳은 지나지 않는다.

크러스컬 알고리즘 Vertex = n, Edge = m O(mlogn)
가중치를 모두 오름차순으로 정렬하고 순서대로 선택한다.
추가하는 값이 들어갔을  때 사이클이 생기면 추가하지 않는다. Union find
반환값에 추가한다.
sort(key = lambda e : e[2])
edgelist형태로 만드는 게 편할 것이다.

Prim알고리즘
임의의 점하나 선택, 간선을 하나씩 추가시켜서 트리 생성

if 간선 (p,v)가 그래프에 있으면
	D[v] = v에 대한 가중치, 비용, 거리
else
	D[v] = inf

T = {p}
while(T에있는 점의 수<n){

}
2차원 배열의 형태로 나타내면 빈공간이 많아져 비효율적이니까 dict로 만들어낸다.
2차원 dict 
dic = {u: dict() for ~~}
몇번 점까지는 얼마다 라는것을 계속 추가해준다.

찾고 갱신하는게 비효율적이다.

모든 점을 연결시킨다.
신장트리는 정확히 n-1개의 간선이 있다.

copy = edge[:] 전체 데이터 복사


2024-11-01
배열의 형태로 저장을 하면 추가와 비교가 편하다.
종류가 몇개 없다면 dict에 저장하는 게 좋다.
가중치에 따라서 다음 간선을 선택하는 알고리즘
dict특성상 추가하는코드랑 갱신 코드가 같다.

튜플로 저장하면 일일히 돌면서 찾아야하고

다운힙 O(nlogn/2) => n
한개를 꺼내고 다운힙을 할때는 logn만큼 만 걸린다.
heapq의 함수 heapq.heappop(arr)을 사용하면 logn의 시간이 걸리지만
그냥 heapify를 사용하면 n의 시간이 걸린다.
heappush
heappop

tuple은 첫번째 속성으로 비교를 해준다.

가중치의 최솟값을 찾는방법 *****************************
heapdict를 사용할 것이다.
heapdict는 pip install heapdict를 사용해야한다.
프림알고리즘이나 다익스트라 알고리즘은 교제에 n^2 알고리즘으로 나오지만
우리는 최소 가중치를 heap구조로 찾을 것이기 때문에 더 적게 나온다.

내륙인가
기존의 값보다 비싸서 무시
싸니까 갱신
없어서 추가

kruskal 간선이 n-1개 라면 루프를 종료한다.

prim 알려진 간선중에 가장 가중치가 적은 간선부터 생성한다.
n-1개의 간선이 생기면 종료한다.
내륙에 n개의 점이 생기면 종료한다.
dict안에 weight가 남아있지 않으면 종료한다.
 -> 이어야할 점이 없다.

입력 : 가중치 그래프
출력 최소 신장 트리

어디서부터 이어진 간선인지 간선정보를 저장해야한다.
prim 알고리즘으로 구한 mst는 사이클이 왜 없나
크루스컬알고리즘은 간선을 추가하다가 사이클이 생기는 간선을 추가하지 않기 때문에 생기지 않는가 ************
프림은 왜 없나 항상간선을 추가할 때 내륙에 있는 점과 내륙 밖에 있는 점만 연결 할 수 있기 때문에 사이클이 만들어지지 않는다. ******************************

최소힙을 써서 간선의 
간선의 개수가 O(n) 일때



최단 경로 찾기 문제 ********
프림알고리즘에 지나온 간선의 가중치가 합산된것을 가중치로 보는 방법
출발점으로 부터의 거리를 나타내는것

2024-11-04
출발점을 0으로 넣어두고 main루프로 들어간다.
간선의 거리가 0이라면 정점만 하나 추가하고 pop해서 없어진다.
D = 이전까지의 거리 + 지금 추가되는 점까지의 거리
간선완화 = D
D를 찾는데 걸리는 시간 logn -> heap으로 구성했을 때

어디서 왔는지 원점을 알고있어야한다.


shortestpath
하나의 점에서는 주위의 점의 수가 일정하다는 가정하에 nlogn이라고 할 수 있다.
heap정렬로 노드를 구할 것이기 때문에


다익스트라 알고리즘 시작점 12번
12번에서 어느점까지 가는 방법을 순서대로 알려준다.
12 -> 21 -> 0과 같이
prim은 시작점이 8번으로

접두부 특성이 뭐냐************************************
하나의 코드가 다른코드의 시작부분이 될 수 없다.
101이라는 코드가 있다면 
101로 시작하는 코드가 있으면 안된다.

허프만 코드와 허프만 코드 트리를 보여주고 
코드가 어떻게 해석되는지 알수 있어야한다.************************


2024-11-11
집합 커버 문제
신도시 계획 문제
부분집합의 합집합이 전체 집합이 되는데 부분집합을 최소로 하는 방법을 찾는 알고리즘
2^n
n이 커지면 최적해를 찾는것은 거의 불가능하다.

매번 부분집합의 원소들이 전체집합에서 몇개나 유효한지 검사한다. -> cnt = len( U & F[i] )

전체 집합의 원소를 가장 많이 가지고 있는 집합을 선택
전체 집합에서 뺀다.
전체집합이 공집합이 될 때까지 반복한다.

deepcopy 
 - set이나 배열이나 dictionary는 안에있는 원소를 모두 카피하기 위해서  [:] 이런 식으로 복사하는것보다 좋다.


다이나믹 프로그래밍 DP
거리탐색문제를 다익스트라보다 간편하게 풀 수 있다.

작은 문제부터 풀어나가서 큰문제를 해결할 때 이미 구했던 해를 사용한다.

분할정복알고리즘과 동적 계획 알고리즘의 차이*****************
분할 정복은 부모노드를 해결하기 위해서 자식노드를 구하지만
동적계획은 어디서 사용될지 모르기 때문에 미리 구해놓고 어디든지 사용할 수 있다.

다이나믹 프로그래밍에서 길찾는 방법은
모든 점에서 다익스트라를 사용한다.

플로이드 워셜 알고리즘
Dijk -> i에서 j로 가는데 
	i에서 j로 바로 가는 비용(Dij0 이 될 수도 있다.)과
	1에서 k까지 중 하나를 거쳐서 가는 비용
	중에서 가장 싼 비용이 저장되어 있다.

2024-11-25 기말고사때 중간과정 제출********
K[i,w] = 물건 1~i까지만 고려하고 배낭의 용량이 w일때의 최대 가치
항상 자연수가 아닐 수 있기 때문에 물건이 0이거나 용량이 0일 때 넣을 수 있는게 없다는것을 2차원 배열에 채우고 시작한다.
반복문에서 윗줄과 비교하는 연산을 위해서도 채워 놓는 게 오류가 나지 않을것이다.

무게와 무게당 가치가 적힌 값이 y축이고 물건을 넣을 수 있는 가방의 크기가 x축인 2차원 배열 
순서대로 물건을 하나씩 넣어보고

동전 문제 
1차원 배열
항상 업데이트


다익스트라알고리즘 
우선순위 큐를 사용해서 nlong의 시간 복잡도를 만들 수 있다.

DP알고리즘
최적화 문제를 해결하는 알고리즘의 하나
부분문제들 사이에 함축적 순서가 있다.

최적 부분 구조
최적 부분 규칙


np 완전 문제
다항식 시간 복잡도를 가진 알고리즘으로 해결되는 문제 집합
p문제 집합
다항식 시간보다 큰 시간복잡도를 가진 알고리즘으로 해결되는 문제 집합
np문제 집합

NP-완전 문제 (NP-Complete Problem)
NP-완전 문제는 다음 두 가지 조건을 만족하는 문제입니다:

NP에 속함: 주어진 해답이 맞는지 확인하는 데 다항 시간(polynomial time)이 걸립니다.

NP-난해 문제로 환원 가능: NP에 속하는 모든 문제는 이 문제로 다항 시간 내에 환원될 수 있습니다.

즉, NP-완전 문제는 NP에 속하는 모든 문제의 대표적인 문제라고 할 수 있습니다. 대표적인 NP-완전 문제로는 SAT 문제(Satisfiability Problem), 여행하는 세일즈맨 문제(Travelling Salesman Problem, TSP) 등이 있습니다.

NP-난해 문제 (NP-Hard Problem)
NP-난해 문제는 다음 조건을 만족하는 문제입니다:

NP에 속하는 모든 문제로 환원 가능: NP에 속하는 모든 문제는 이 문제로 다항 시간 내에 환원될 수 있습니다.

하지만 NP-난해 문제는 반드시 NP에 속할 필요는 없습니다. 즉, NP-난해 문제는 결정 문제일 수도 있고, 아닐 수도 있습니다. 대표적인 NP-난해 문제로는 해밀턴 경로 문제(Hamiltonian Path Problem), 최적화 문제(Optimization Problem) 등이 있습니다.

추측한 해를 맞다/아니다로 출력이 나와야한다.

문제 변환

partition이 완료된 문제를 
subsetsum의 형태로 해결하는 방법이 기말고사에 나올것이다.********

2024-11-29
10kg배낭 2kg로 자르면된다.
임의의 무게 임의의 배낭이면 풀수 없는 문제가 된다.

정점커버
정점으로 정점을 커버하는 문제 -> 정점과 바로 연결되어 있는 정점들의 집합
정점으로 간선을 커버하는 문제 -> 정점과 연결되어있는 간선들의 집합
set cover로 풀수 있지 않냐 -> 가장 작은 부분집합들로 합집합을 이뤘을 때 전체집합이 되는 것 -> 무손실 분해
이것또한 np 완전 문제라 풀수없다.
근사값을 구하는 
1 2 4 5를 부분집합으로 한다.

클리크 -> 모든 정점들이 서로 연결되어 있을 때

그래프 색칠하기 문제
최장 경로 문제
여행자 문제
헤밀토니안 사이클 -> 여행자 문제에서 가중치를 없앤것
통 채우기
작업 스케줄링


근사 알고리즘
greedy 알고리즘
실제정답과 비슷한 값을 내 놓느냐
실제 정답을 알 수 없으니 어느정도 추측해본다.

여행자 문제 TSP
	MST와 비슷하다.
	모든 도시를 1번씩 방문해서 돌아오는 비용이 최소이어야 한다
	삼각부등식 특성 -> a에서 c까지 바로 가는 것이 a -> b -> c가 더 가깝다
	mst를 사용해서 해를 구하고 갈 수 있는 길로 진행하다가 더이상 갈 수 있는 곳이 없다면
	이전의 점으로 돌아가는 순서를 저장하고 1->2->3->4 이런 식으로
	다시 1까지 돌아간 후
	중복되는 숫자를 지운다.
	이 방법은 삼각 부등식의 원리를 적용한 사례이다.

집합커버

극대 매칭
	각지역의 대표선수들이 대중교통을 이용해서 이동할 수 있는 거리가 제한되어있다.
	선수 두명씩 선발해서 경기를 하라고 한다.
	더이상 새로운 간선을 추가할 수 없는 상황

통 채우기******************************어떤순서로 물건이 들어가는가를 알아야한다
	용량이 C인 통에 n개의 물건을 넣어야한다.
최초적합 (First Fit):
정의: 메모리에서 첫 번째로 충분한 크기의 빈 블록을 찾아 할당합니다.
장점: 빠른 할당 속도.
단점: 메모리 단편화가 발생할 수 있습니다.

다음적합 (Next Fit):
정의: 이전 할당 위치에서부터 시작하여 충분한 크기의 빈 블록을 찾아 할당합니다.
장점: 메모리 단편화를 줄일 수 있습니다.
단점: 여전히 단편화가 발생할 수 있습니다.

최선적합 (Best Fit):
정의: 메모리에서 가장 작은 충분한 크기의 빈 블록을 찾아 할당합니다.
장점: 메모리 사용 효율이 높습니다.
단점: 검색 시간이 오래 걸릴 수 있으며, 작은 빈 블록들이 많이 남아 단편화가 발생할 수 있습니다.

최악적합 (Worst Fit):
정의: 메모리에서 가장 큰 빈 블록을 찾아 할당합니다.
장점: 큰 빈 블록을 남겨두어 큰 메모리 요청을 처리할 수 있습니다.
단점: 메모리 사용 효율이 낮아질 수 있습니다.

작업 스케줄링
	현재 작업에 대해서 가장빨리 끝나는 기계에 작업을 새로 할당해준다.
	가장 마지막에 끝나는 작업이 가장 빨리끝나는 알고리즘이 좋은 알고리즘이다.

클러스터링
	그룹을 나눈 원의 직경이 최소가 되도록 나눠야 한다.	
	random으로 주인공을 선택하고 주인공들을 기준으로 원을 만든다.
	주인공을 기준으로 가장 먼 점을 두번째 주인공으로 만든다.
	또 주인공을 만든다면 기존의 주인공들에서 가장 먼 점을 주인공으로 만든다.

	