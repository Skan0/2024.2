2024-10-25
그리디 알고리즘은 일단 한번 선택하면 이를 절대로 번복하지 않는다.
선택한 데이터를 버리고 다른것을 취하지 않는다.
이러한 특성 때문에 대부분의 그리디 알고리즘들은 매우 단순하며 또한 제한적인 문제만이 그리디 알고리즘으로 해결된다.

지수형태의 시간 복잡도 알고리즘을 가진 문제들을 너무 오래 걸리니까
그리디 알고리즘으로 근사값이라도 풀어보자 

동전 거스름돈 문제
남은 액수를 초과하지 않는 조건하에 욕심내어 가장 큰 액면의 동전을 취하는것

근시안적으로 해결가능한 문제만 풀 수 있다
160원짜리가 생기면 더이상 해결가능한 문제가 아니게 되어버린다.
항상 사용가능한 알고리즘이 아니라 특정 상황일 때만 사용가능하다.


최소신장트리 - MST
주어진 가중치 그래프에서 사이클 없이 모든 점을 연결 시킨 트리들중 가중치 합이 최소인 트리
트리는 사이클이 없어야 한다.
spanning 모든 점을 지나가는가
n개의 점이 있을 때 n-1개의 간선이 있다.
어느 한 선을 추가하면 반드시 사이클이 생긴다.


정점들이 간선들로 이어지고 있는 형태를 트리라고 한다.
점들이 서로 연결된 방향에 따라 어디에 연결되어 있는지 확인해도 좋지만 보통 A에서 B로 연결된것을 B에서 A로 연결되어있다고 A에도 저장하고 B에도 저장한다.

adjacency matrix 간선 한개로 연결되어 있는 값만 나타낸 행렬
아예 연결되어있지 않다면 무한대를 넣어도 좋다. 무한대로 넣으면 비교해서 간선을 선택하는 코드가 좀더 자연스럽게 흘러갈 수 있다.
none이나 null을 넣어도 좋지만 항상 체크를 해야한다.

adjacency list 연결된 정점들을 나타내는 리스트
set 상수시간의 시간복잡도가 걸린다.
시작점을 key값으로 하고 연결된 정점들을 value로 하는 dic로 나타내도 좋다.

저장은 list형태로 사용하고 표현은 matrix의 형태로 한다.

edgelist도 있다.

크러스컬 알고리즘
	가중치가 가장 적은 간선이 사이클을 만들지 않을 때에만 간선을 추가한다.
프림 알고리즘
	임의의 점 하나를 선택한후 n-1개의 간선을 하나씩 추가시켜 트리를 만든다.

2024-10-28
MST minimum spanning tree
spanning 모든간선을 연결한것

트리일수 있는 경우의 수에서 간선의 합이 가장 적은형태
크러스컬 - 지금당장 선택할 수 있는것을 선택한다. 가중치가 최소인 간선을 지나는데 이미 이어져 있다면 지나지 않는다. Union find -> 같은 루트를 가지고 있는가
프림 - 한점을 선정하고 이 점에서 다른 점으로의 간선중 최소인 점을 지나고 지나온 점을 포함해서 최소인 간선을 찾아서 또 연결하지만 이미 지난곳은 지나지 않는다.

크러스컬 알고리즘 Vertex = n, Edge = m O(mlogn)
가중치를 모두 오름차순으로 정렬하고 순서대로 선택한다.
추가하는 값이 들어갔을  때 사이클이 생기면 추가하지 않는다. Union find
반환값에 추가한다.
sort(key = lambda e : e[2])
edgelist형태로 만드는 게 편할 것이다.

Prim알고리즘
임의의 점하나 선택, 간선을 하나씩 추가시켜서 트리 생성

if 간선 (p,v)가 그래프에 있으면
	D[v] = v에 대한 가중치, 비용, 거리
else
	D[v] = inf

T = {p}
while(T에있는 점의 수<n){

}
2차원 배열의 형태로 나타내면 빈공간이 많아져 비효율적이니까 dict로 만들어낸다.
2차원 dict 
dic = {u: dict() for ~~}
몇번 점까지는 얼마다 라는것을 계속 추가해준다.

찾고 갱신하는게 비효율적이다.

모든 점을 연결시킨다.
신장트리는 정확히 n-1개의 간선이 있다.

copy = edge[:] 전체 데이터 복사


2024-11-01
배열의 형태로 저장을 하면 추가와 비교가 편하다.
종류가 몇개 없다면 dict에 저장하는 게 좋다.
가중치에 따라서 다음 간선을 선택하는 알고리즘
dict특성상 추가하는코드랑 갱신 코드가 같다.

튜플로 저장하면 일일히 돌면서 찾아야하고

다운힙 O(nlogn/2) => n
한개를 꺼내고 다운힙을 할때는 logn만큼 만 걸린다.
heapq의 함수 heapq.heappop(arr)을 사용하면 logn의 시간이 걸리지만
그냥 heapify를 사용하면 n의 시간이 걸린다.
heappush
heappop

tuple은 첫번째 속성으로 비교를 해준다.

가중치의 최솟값을 찾는방법 *****************************
heapdict를 사용할 것이다.
heapdict는 pip install heapdict를 사용해야한다.
프림알고리즘이나 다익스트라 알고리즘은 교제에 n^2 알고리즘으로 나오지만
우리는 최소 가중치를 heap구조로 찾을 것이기 때문에 더 적게 나온다.

내륙인가
기존의 값보다 비싸서 무시
싸니까 갱신
없어서 추가

kruskal 간선이 n-1개 라면 루프를 종료한다.

prim 알려진 간선중에 가장 가중치가 적은 간선부터 생성한다.
n-1개의 간선이 생기면 종료한다.
내륙에 n개의 점이 생기면 종료한다.
dict안에 weight가 남아있지 않으면 종료한다.
 -> 이어야할 점이 없다.

입력 : 가중치 그래프
출력 최소 신장 트리

어디서부터 이어진 간선인지 간선정보를 저장해야한다.
prim 알고리즘으로 구한 mst는 사이클이 왜 없나
크루스컬알고리즘은 간선을 추가하다가 사이클이 생기는 간선을 추가하지 않기 때문에 생기지 않는가 ************
프림은 왜 없나 항상간선을 추가할 때 내륙에 있는 점과 내륙 밖에 있는 점만 연결 할 수 있기 때문에 사이클이 만들어지지 않는다. ******************************

최소힙을 써서 간선의 
간선의 개수가 O(n) 일때



최단 경로 찾기 문제 ********
프림알고리즘에 지나온 간선의 가중치가 합산된것을 가중치로 보는 방법
출발점으로 부터의 거리를 나타내는것

2024-11-04
출발점을 0으로 넣어두고 main루프로 들어간다.
간선의 거리가 0이라면 정점만 하나 추가하고 pop해서 없어진다.
D = 이전까지의 거리 + 지금 추가되는 점까지의 거리
간선완화 = D
D를 찾는데 걸리는 시간 logn -> heap으로 구성했을 때

어디서 왔는지 원점을 알고있어야한다.


shortestpath
하나의 점에서는 주위의 점의 수가 일정하다는 가정하에 nlogn이라고 할 수 있다.
heap정렬로 노드를 구할 것이기 때문에


다익스트라 알고리즘 시작점 12번
12번에서 어느점까지 가는 방법을 순서대로 알려준다.
12 -> 21 -> 0과 같이
prim은 시작점이 8번으로

접두부 특성이 뭐냐************************************
하나의 코드가 다른코드의 시작부분이 될 수 없다.
101이라는 코드가 있다면 
101로 시작하는 코드가 있으면 안된다.

허프만 코드와 허프만 코드 트리를 보여주고 
코드가 어떻게 해석되는지 알수 있어야한다.************************


2024-11-11
집합 커버 문제
신도시 계획 문제
부분집합의 합집합이 전체 집합이 되는데 부분집합을 최소로 하는 방법을 찾는 알고리즘
2^n
n이 커지면 최적해를 찾는것은 거의 불가능하다.

매번 부분집합의 원소들이 전체집합에서 몇개나 유효한지 검사한다. -> cnt = len( U & F[i] )

전체 집합의 원소를 가장 많이 가지고 있는 집합을 선택
전체 집합에서 뺀다.
전체집합이 공집합이 될 때까지 반복한다.

deepcopy 
 - set이나 배열이나 dictionary는 안에있는 원소를 모두 카피하기 위해서  [:] 이런 식으로 복사하는것보다 좋다.


다이나믹 프로그래밍 DP
거리탐색문제를 다익스트라보다 간편하게 풀 수 있다.

작은 문제부터 풀어나가서 큰문제를 해결할 때 이미 구했던 해를 사용한다.

분할정복알고리즘과 동적 계획 알고리즘의 차이*****************
분할 정복은 부모노드를 해결하기 위해서 자식노드를 구하지만
동적계획은 어디서 사용될지 모르기 때문에 미리 구해놓고 어디든지 사용할 수 있다.

다이나믹 프로그래밍에서 길찾는 방법은
모든 점에서 다익스트라를 사용한다.

플로이드 워셜 알고리즘
Dijk -> i에서 j로 가는데 
	i에서 j로 바로 가는 비용(Dij0 이 될 수도 있다.)과
	1에서 k까지 중 하나를 거쳐서 가는 비용
	중에서 가장 싼 비용이 저장되어 있다.

2024-11-25 기말고사때 중간과정 제출********
K[i,w] = 물건 1~i까지만 고려하고 배낭의 용량이 w일때의 최대 가치
항상 자연수가 아닐 수 있기 때문에 물건이 0이거나 용량이 0일 때 넣을 수 있는게 없다는것을 2차원 배열에 채우고 시작한다.
반복문에서 윗줄과 비교하는 연산을 위해서도 채워 놓는 게 오류가 나지 않을것이다.

무게와 무게당 가치가 적힌 값이 y축이고 물건을 넣을 수 있는 가방의 크기가 x축인 2차원 배열 
순서대로 물건을 하나씩 넣어보고

동전 문제 
1차원 배열
항상 업데이트


다익스트라알고리즘 
우선순위 큐를 사용해서 nlong의 시간 복잡도를 만들 수 있다.

DP알고리즘
최적화 문제를 해결하는 알고리즘의 하나
부분문제들 사이에 함축적 순서가 있다.

최적 부분 구조
최적 부분 규칙


np 완전 문제
다항식 시간 복잡도를 가진 알고리즘으로 해결되는 문제 집합
p문제 집합
다항식 시간보다 큰 시간복잡도를 가진 알고리즘으로 해결되는 문제 집합
np문제 집합

NP-완전 문제 (NP-Complete Problem)
NP-완전 문제는 다음 두 가지 조건을 만족하는 문제입니다:

NP에 속함: 주어진 해답이 맞는지 확인하는 데 다항 시간(polynomial time)이 걸립니다.

NP-난해 문제로 환원 가능: NP에 속하는 모든 문제는 이 문제로 다항 시간 내에 환원될 수 있습니다.

즉, NP-완전 문제는 NP에 속하는 모든 문제의 대표적인 문제라고 할 수 있습니다. 대표적인 NP-완전 문제로는 SAT 문제(Satisfiability Problem), 여행하는 세일즈맨 문제(Travelling Salesman Problem, TSP) 등이 있습니다.

NP-난해 문제 (NP-Hard Problem)
NP-난해 문제는 다음 조건을 만족하는 문제입니다:

NP에 속하는 모든 문제로 환원 가능: NP에 속하는 모든 문제는 이 문제로 다항 시간 내에 환원될 수 있습니다.

하지만 NP-난해 문제는 반드시 NP에 속할 필요는 없습니다. 즉, NP-난해 문제는 결정 문제일 수도 있고, 아닐 수도 있습니다. 대표적인 NP-난해 문제로는 해밀턴 경로 문제(Hamiltonian Path Problem), 최적화 문제(Optimization Problem) 등이 있습니다.

추측한 해를 맞다/아니다로 출력이 나와야한다.

문제 변환

partition이 완료된 문제를 
subsetsum의 형태로 해결하는 방법이 기말고사에 나올것이다.********

2024-11-29
10kg배낭 2kg로 자르면된다.
임의의 무게 임의의 배낭이면 풀수 없는 문제가 된다.

정점커버
정점으로 정점을 커버하는 문제 -> 정점과 바로 연결되어 있는 정점들의 집합
정점으로 간선을 커버하는 문제 -> 정점과 연결되어있는 간선들의 집합
set cover로 풀수 있지 않냐 -> 가장 작은 부분집합들로 합집합을 이뤘을 때 전체집합이 되는 것 -> 무손실 분해
이것또한 np 완전 문제라 풀수없다.
근사값을 구하는 
1 2 4 5를 부분집합으로 한다.

클리크 -> 모든 정점들이 서로 연결되어 있을 때

그래프 색칠하기 문제
최장 경로 문제
여행자 문제
헤밀토니안 사이클 -> 여행자 문제에서 가중치를 없앤것
통 채우기
작업 스케줄링


근사 알고리즘
greedy 알고리즘
실제정답과 비슷한 값을 내 놓느냐
실제 정답을 알 수 없으니 어느정도 추측해본다.

여행자 문제 TSP
	MST와 비슷하다.
	모든 도시를 1번씩 방문해서 돌아오는 비용이 최소이어야 한다
	삼각부등식 특성 -> a에서 c까지 바로 가는 것이 a -> b -> c가 더 가깝다
	mst를 사용해서 해를 구하고 갈 수 있는 길로 진행하다가 더이상 갈 수 있는 곳이 없다면
	이전의 점으로 돌아가는 순서를 저장하고 1->2->3->4 이런 식으로
	다시 1까지 돌아간 후
	중복되는 숫자를 지운다.
	이 방법은 삼각 부등식의 원리를 적용한 사례이다.

집합커버

극대 매칭
	각지역의 대표선수들이 대중교통을 이용해서 이동할 수 있는 거리가 제한되어있다.
	선수 두명씩 선발해서 경기를 하라고 한다.
	더이상 새로운 간선을 추가할 수 없는 상황

통 채우기******************************어떤순서로 물건이 들어가는가를 알아야한다
	용량이 C인 통에 n개의 물건을 넣어야한다.
최초적합 (First Fit):
정의: 메모리에서 첫 번째로 충분한 크기의 빈 블록을 찾아 할당합니다.
장점: 빠른 할당 속도.
단점: 메모리 단편화가 발생할 수 있습니다.

다음적합 (Next Fit):
정의: 이전 할당 위치에서부터 시작하여 충분한 크기의 빈 블록을 찾아 할당합니다.
장점: 메모리 단편화를 줄일 수 있습니다.
단점: 여전히 단편화가 발생할 수 있습니다.

최선적합 (Best Fit):
정의: 메모리에서 가장 작은 충분한 크기의 빈 블록을 찾아 할당합니다.
장점: 메모리 사용 효율이 높습니다.
단점: 검색 시간이 오래 걸릴 수 있으며, 작은 빈 블록들이 많이 남아 단편화가 발생할 수 있습니다.

최악적합 (Worst Fit):
정의: 메모리에서 가장 큰 빈 블록을 찾아 할당합니다.
장점: 큰 빈 블록을 남겨두어 큰 메모리 요청을 처리할 수 있습니다.
단점: 메모리 사용 효율이 낮아질 수 있습니다.

작업 스케줄링
	현재 작업에 대해서 가장빨리 끝나는 기계에 작업을 새로 할당해준다.
	가장 마지막에 끝나는 작업이 가장 빨리끝나는 알고리즘이 좋은 알고리즘이다.

클러스터링
	그룹을 나눈 원의 직경이 최소가 되도록 나눠야 한다.	
	random으로 주인공을 선택하고 주인공들을 기준으로 원을 만든다.
	주인공을 기준으로 가장 먼 점을 두번째 주인공으로 만든다.
	또 주인공을 만든다면 기존의 주인공들에서 가장 먼 점을 주인공으로 만든다.


근사알고리즘은 최적해에 가까운 해인 근사해를 찾는 대신에 다항식 시간의 복잡도를 가진다.
근사비율은 근사해가 얼마나 최적해에 가까운지를 나타내는 근사해의 값과 최적해의 값의 비율로서 1.0에 가까울 수록 실용성이 높은 알고리즘
ㅇㅕ행자 문제는 mst의 모든 점을 연결하는 특성과 최소 가중치의 특성을 사용한다.
통채우기는 4가지의 전략이 있었고 시간 복잡도는 nextfit이 가장 좋지만 통을 많이 사용해서  별로다.

2024-12-02
Mst Tsp
MST를 먼저 진행하고 접혀져 있는 곳을 펴준다는 느낌으로 진행 할 것이다.
튜플로 mst를 구해도 상관없지만 다익스트라를 할때는 

이미 내륙에 있는 점이라면 선을 잇지 안느

별모양으로 5개의 길이 있다 가운데에서 시작 
시작점 위치에 데이터가 남아있다면 TSP라고 할지라도 계속 진행한다.
keys()라는 함수generator처럼 사용한다.?//
방문하지 않은 점이면 방문하고
방문하지 않은 점이 하나면 중복된점들을 지우고 마지막 숫자를 방문한 수열에 추가한뒤 
아니라면 아무거나 찾는다.

Vertex cover
main 함수 두개로
setcover와 maxmatch의 main을 가져왔다.
부분집합들로 최소한의 개수를 선택해서 전체 집합이 되도록한다.
점을 하나 선택했을 때 갈수 있는 모든점을 값으로 갖는 부분집합
근사비율이 2.0보다 높아질 수 있는 단점이 있다.
 
2024-12-06
first fit 앞에서 부터 통에 들어갈 수 있다면 넣기
next fit 이전에 넣었던 통에 빈공간이 새로들어갈 것의 크기 만큼 있는가만 보고 없다면 next
best fit 들어갈 수 있으면서 공간이 가장 작은곳에 넣기
worst fit 들어갈 수 있으면서 공간이 가장 큰곳에 넣기

클러스터링 알고리즘에서
heapdict를 사용해서 dictionary(거리, 도시이름)중 가장 거리가 먼 도시를 찾아서  새로운 center로 만든다.

/////////////////////////
최소신장트리
크러스컬
m개의 트리가 n개의 트리로 바뀌는 시간 복잡도를 가진다.
가장 싼 선부터 연결한다.
프림 알고리즘
현재 연결되어있는 선에서 뻗어나갈때 가장 싼 선을 추가한다.

간선을 추가추가하다가 사이클이 생기면 추가하지 않는다.
내륙인가 아닌가를 판단하고 내륙과 내륙이 아닌점만을 연결하는게 
크러스컬과 프림의 차이점

adjacency list dict형식이나 set을 사용했따.

최소신장트리가 진행중일때 다음에 어떤 선이 이어지는가를 보는 문제가 나온다.
교제에 참고할 만한 문제가 있다.

내륙이면 continue
기존의 것인데 더 싸다면 continue
prim 알고리즘
코드를 살펴보는것이 좋겠다.
중간과정이 이런데 다음것은 어떻게 할것이냐 하는 문제가 있을것이다.***

시간복잡도가 mlongn인 이유를 알아야한다.***
heap을 이용해서 최솟값을 찾는다
간선의 개수 m


부분배낭문제 greedy로 풀수 있따.
0-1배낭문제는 조건에 따라 달라진다.
무게의 단위가 큼직하게 나눌수 있다면 다이나믹 프로그래밍으로 풀수 있다.
작다면 나눠야할 부분이 너무 많아져서 풀수없는 문제가된다.

정점으로 정점을 커버하는 문제
setcover로 해결 할 수 있는데 최적해를 구할 수 없다.
근사해만 구할 수 있었다.

부분집합들로 전체집합을 나타낼 수 있게 만드는데 선택하는 부분집합의 개수를 가장 적게 선택하는 알고리즘
중간과정들 물어보는 문제가 있을 것이다.***

작업스케쥴링 문제
시작시간 순서로 정렬하는 시간
정렬된 순서로 배치하는시간
가장 빨리 끝나는곳에 새로운 일을 배치하는것으로 그리디 형태로 풀수 있었다.

허프만 압축
모든 글자에게 동일한 비트를 부여하지 말자
더 자주 사용되는곳에 더 많은 비트를 부여하고 적게 사용되는것은 적게 부여하자
빈도수를 구해서 가장 적은 수의 문자를 노드로 만들고 큐에 넣는다 빈도수가 적으면 적을수록 트리에서 레벨이 내려간다.
허프만 압축에서 디코딩 하는 문제가 나올것이다.****

dynamic programming
작은 문제부터 차근차근 풀어나가는 방식
작은 문제의 해가 큰문제를 푸는데 사용될 것이다.
divide and conqure
닮은점과 차이점을 알아둬야한다.**

플로이드 워셜이 훨씬 간단하다.
구현하는 코드가 시험에 나올거같다.
n이 충분히 커질때까지 쓸만하다.

mst tsp에서의삼각형은 가정이다.
지도위에서 3점을 연결하는 직선을 얘기한다.
삼각형의 두변의 합이 다른 변의 합보다 크다라는 가정하게 만들어짐

Dij1 i부터j까지 가는데 1을 거쳐서 가는게 더싼가

같으면 continue만 시켜주고 
교제의 연습문제를 풀어보면 좋겠다.G

연속 행렬 곱셈
결합법칙이 가능하기 때문에
어떤순서로 곱해야하는가
어디서 최종 곱셈을 하는가를 물을 것이다.**

n원에서 k원 만큼 뺀뒤 동전의 개수를 1더해 주는식으로 계산한다.
중에서 가장 동전수가 적은 것을 상욯나다.

p문제 다항식시간으로 설명가능한 문제
np문제 지수시간이 걸리는 문제

모든 문제가 a로 변환이 가능하다면 a를 하드np라고 한다.

SAT
어떤문제의 예가 어떤 문제가 있는지 라는 문제가 나올 수 있다.***

근사 알고리즘
근사 비율과 함께 제시해야한다.
간접적인 최적해로 근사비율을 찾는다.

삼각부등식원리에 의해서 추측했을 뿐이지 진실이 아니다.
작을것 같으므로 2m보다 작을 것이다~

극대 매칭
 set cover보다 좋다.

통채우기 문제 
최종 통이 몇개 사용되겠느냐
이 그림을 보고 사용된 통채우기 방법을 적어라
와 같은 문제
nextfit
worstfit
firstfit
bestfit
	

