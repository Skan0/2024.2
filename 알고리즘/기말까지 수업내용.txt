2024-10-25
그리디 알고리즘은 일단 한번 선택하면 이를 절대로 번복하지 않는다.
선택한 데이터를 버리고 다른것을 취하지 않는다.
이러한 특성 때문에 대부분의 그리디 알고리즘들은 매우 단순하며 또한 제한적인 문제만이 그리디 알고리즘으로 해결된다.

지수형태의 시간 복잡도 알고리즘을 가진 문제들을 너무 오래 걸리니까
그리디 알고리즘으로 근사값이라도 풀어보자 

동전 거스름돈 문제
남은 액수를 초과하지 않는 조건하에 욕심내어 가장 큰 액면의 동전을 취하는것

근시안적으로 해결가능한 문제만 풀 수 있다
160원짜리가 생기면 더이상 해결가능한 문제가 아니게 되어버린다.
항상 사용가능한 알고리즘이 아니라 특정 상황일 때만 사용가능하다.


최소신장트리 - MST
주어진 가중치 그래프에서 사이클 없이 모든 점을 연결 시킨 트리들중 가중치 합이 최소인 트리
트리는 사이클이 없어야 한다.
spanning 모든 점을 지나가는가
n개의 점이 있을 때 n-1개의 간선이 있다.
어느 한 선을 추가하면 반드시 사이클이 생긴다.


정점들이 간선들로 이어지고 있는 형태를 트리라고 한다.
점들이 서로 연결된 방향에 따라 어디에 연결되어 있는지 확인해도 좋지만 보통 A에서 B로 연결된것을 B에서 A로 연결되어있다고 A에도 저장하고 B에도 저장한다.

adjacency matrix 간선 한개로 연결되어 있는 값만 나타낸 행렬
아예 연결되어있지 않다면 무한대를 넣어도 좋다. 무한대로 넣으면 비교해서 간선을 선택하는 코드가 좀더 자연스럽게 흘러갈 수 있다.
none이나 null을 넣어도 좋지만 항상 체크를 해야한다.

adjacency list 연결된 정점들을 나타내는 리스트
set 상수시간의 시간복잡도가 걸린다.
시작점을 key값으로 하고 연결된 정점들을 value로 하는 dic로 나타내도 좋다.

저장은 list형태로 사용하고 표현은 matrix의 형태로 한다.

edgelist도 있다.

크러스컬 알고리즘
	가중치가 가장 적은 간선이 사이클을 만들지 않을 때에만 간선을 추가한다.
프림 알고리즘
	임의의 점 하나를 선택한후 n-1개의 간선을 하나씩 추가시켜 트리를 만든다.

2024-10-28
MST minimum spanning tree
spanning 모든간선을 연결한것

트리일수 있는 경우의 수에서 간선의 합이 가장 적은형태
크러스컬 - 지금당장 선택할 수 있는것을 선택한다. 가중치가 최소인 간선을 지나는데 이미 이어져 있다면 지나지 않는다. Union find -> 같은 루트를 가지고 있는가
프림 - 한점을 선정하고 이 점에서 다른 점으로의 간선중 최소인 점을 지나고 지나온 점을 포함해서 최소인 간선을 찾아서 또 연결하지만 이미 지난곳은 지나지 않는다.

크러스컬 알고리즘 Vertex = n, Edge = m O(mlogn)
가중치를 모두 오름차순으로 정렬하고 순서대로 선택한다.
추가하는 값이 들어갔을  때 사이클이 생기면 추가하지 않는다. Union find
반환값에 추가한다.
sort(key = lambda e : e[2])
edgelist형태로 만드는 게 편할 것이다.

Prim알고리즘
임의의 점하나 선택, 간선을 하나씩 추가시켜서 트리 생성

if 간선 (p,v)가 그래프에 있으면
	D[v] = v에 대한 가중치, 비용, 거리
else
	D[v] = inf

T = {p}
while(T에있는 점의 수<n){

}
2차원 배열의 형태로 나타내면 빈공간이 많아져 비효율적이니까 dict로 만들어낸다.
2차원 dict 
dic = {u: dict() for ~~}
몇번 점까지는 얼마다 라는것을 계속 추가해준다.

찾고 갱신하는게 비효율적이다.

모든 점을 연결시킨다.
신장트리는 정확히 n-1개의 간선이 있다.

copy = edge[:] 전체 데이터 복사


2024-11-01
배열의 형태로 저장을 하면 추가와 비교가 편하다.
종류가 몇개 없다면 dict에 저장하는 게 좋다.
가중치에 따라서 다음 간선을 선택하는 알고리즘
dict특성상 추가하는코드랑 갱신 코드가 같다.

튜플로 저장하면 일일히 돌면서 찾아야하고

다운힙 O(nlogn/2) => n
한개를 꺼내고 다운힙을 할때는 logn만큼 만 걸린다.
heapq의 함수 heapq.heappop(arr)을 사용하면 logn의 시간이 걸리지만
그냥 heapify를 사용하면 n의 시간이 걸린다.
heappush
heappop

tuple은 첫번째 속성으로 비교를 해준다.

가중치의 최솟값을 찾는방법 *****************************
heapdict를 사용할 것이다.
heapdict는 pip install heapdict를 사용해야한다.
프림알고리즘이나 다익스트라 알고리즘은 교제에 n^2 알고리즘으로 나오지만
우리는 최소 가중치를 heap구조로 찾을 것이기 때문에 더 적게 나온다.

내륙인가
기존의 값보다 비싸서 무시
싸니까 갱신
없어서 추가

kruskal 간선이 n-1개 라면 루프를 종료한다.

prim 알려진 간선중에 가장 가중치가 적은 간선부터 생성한다.
n-1개의 간선이 생기면 종료한다.
내륙에 n개의 점이 생기면 종료한다.
dict안에 weight가 남아있지 않으면 종료한다.
 -> 이어야할 점이 없다.

입력 : 가중치 그래프
출력 최소 신장 트리

어디서부터 이어진 간선인지 간선정보를 저장해야한다.
prim 알고리즘으로 구한 mst는 사이클이 왜 없나
크루스컬알고리즘은 간선을 추가하다가 사이클이 생기는 간선을 추가하지 않기 때문에 생기지 않는가 ************
프림은 왜 없나 항상간선을 추가할 때 내륙에 있는 점과 내륙 밖에 있는 점만 연결 할 수 있기 때문에 사이클이 만들어지지 않는다. ******************************

최소힙을 써서 간선의 
간선의 개수가 O(n) 일때



최단 경로 찾기 문제 ********
프림알고리즘에 지나온 간선의 가중치가 합산된것을 가중치로 보는 방법
출발점으로 부터의 거리를 나타내는것

2024-11-04
출발점을 0으로 넣어두고 main루프로 들어간다.
간선의 거리가 0이라면 정점만 하나 추가하고 pop해서 없어진다.
D = 이전까지의 거리 + 지금 추가되는 점까지의 거리
간선완화 = D
D를 찾는데 걸리는 시간 logn -> heap으로 구성했을 때

어디서 왔는지 원점을 알고있어야한다.


shortestpath
하나의 점에서는 주위의 점의 수가 일정하다는 가정하에 nlogn이라고 할 수 있다.
heap정렬로 노드를 구할 것이기 때문에


다익스트라 알고리즘 시작점 12번
12번에서 어느점까지 가는 방법을 순서대로 알려준다.
12 -> 21 -> 0과 같이
prim은 시작점이 8번으로

접두부 특성이 뭐냐************************************
하나의 코드가 다른코드의 시작부분이 될 수 없다.
101이라는 코드가 있다면 
101로 시작하는 코드가 있으면 안된다.

허프만 코드와 허프만 코드 트리를 보여주고 
코드가 어떻게 해석되는지 알수 있어야한다.************************


2024-11-11
집합 커버 문제
신도시 계획 문제
부분집합의 합집합이 전체 집합이 되는데 부분집합을 최소로 하는 방법을 찾는 알고리즘
2^n
n이 커지면 최적해를 찾는것은 거의 불가능하다.

매번 부분집합의 원소들이 전체집합에서 몇개나 유효한지 검사한다. -> cnt = len( U & F[i] )

전체 집합의 원소를 가장 많이 가지고 있는 집합을 선택
전체 집합에서 뺀다.
전체집합이 공집합이 될 때까지 반복한다.

deepcopy 
 - set이나 배열이나 dictionary는 안에있는 원소를 모두 카피하기 위해서  [:] 이런 식으로 복사하는것보다 좋다.


다이나믹 프로그래밍 DP
거리탐색문제를 다익스트라보다 간편하게 풀 수 있다.

작은 문제부터 풀어나가서 큰문제를 해결할 때 이미 구했던 해를 사용한다.

분할정복알고리즘과 동적 계획 알고리즘의 차이*****************
분할 정복은 부모노드를 해결하기 위해서 자식노드를 구하지만
동적계획은 어디서 사용될지 모르기 때문에 미리 구해놓고 어디든지 사용할 수 있다.

다이나믹 프로그래밍에서 길찾는 방법은
모든 점에서 다익스트라를 사용한다.

플로이드 워셜 알고리즘
Dijk -> i에서 j로 가는데 
	i에서 j로 바로 가는 비용(Dij0 이 될 수도 있다.)과
	1에서 k까지 중 하나를 거쳐서 가는 비용
	중에서 가장 싼 비용이 저장되어 있다.



























