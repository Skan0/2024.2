알고리즘 정리

알고리즘은 문제 해결의 단계적인 절차에서 어떻게를 담당하고 있다.
요리책에서 요리를 맛있게 만드는 방법을 알려주듯이
알고리즘에서는 코드를 어떻게 효율적으로 만들 수 있는지 알려준다.

일반적으로 알고리즘은 간단하게 나타낼 때 pseudo 코드를 사용하지만
개발자가 아닌 코딩을 잘 모르는 사람에게 설명할 때는 플로우 차트를 사용하는 경우도 있다.
(플로우차트가 어떤식으로 만들어지는지 알아둬야겠다) -> 중요하다고 말하신건 아님 내 생각

미로찾기 - 오른손의 법칙(문제의 본질을 해치지 않는 방법으로 해를 구해야 한다.)
동전찾기 - 양팔저울 사용횟수를 최소로 해서 해를 찾는다. greedy알고리즘
한붓그리기 - 사이클이 존재한다면 진행한다. (현재 가려고 하는 길을 제외하고도 다른 길을 통해서 가려고 했던 길로 갈 수 있다면)
		- 갈 수 있는 길이 하나만 존재한다면 진행한다.
		- 정점에서 다른정점으로 가는 선 그것을 차수라고 하는데 전채 그림에서 차수가 홀수인 정점의 개수가 2를 초과할 경우 한붓그리기가 불가능해진다.

알고리즘은
정확성 - 주어진 입력에 대해 올바른 해를 구해야한다.
유한성 - 유한시간 내에 종료되어야 한다.
수행성 - 알고리즘은 최소 1개 이상의 결과를 가진다.
효율성 - 알고리즘은 효율적이어야 한다.


효율적인 수행시간,
사용하는 메모리 크기, 
개발 복잡도가 고려될 수 있다.

퀵소트는 최악이 아니라 평균으로 말한다. -> 퀵소트가 대부분 O(nlogn)의 시간 복잡도를 가지는데 최악의 경우 O(n^2)까지 갈수있기 때문에 이렇게 말하신듯

빅오 -> 알고리즘의 상한 			가장 느리게 표현한다.
빅오메가 -> 알고리즘의 하한			가장 빠르게 표현한다.
빅세타 -> 상한과 하한 사이 평균		동일한 증가율이라는데 뭔말인지 모르겠다.
시험문제에 빅오라고 표기되어있어도 빅세타 일수 있으므로 잘파악해서 풀어보자

시간복잡도 증가율
O(1)
O(logn)
O(n)
O(nlogn)
O(n^2)
O(n^3)
O(n^k)
O(k^n)
O(n!)

내부정렬 - 컴퓨터 내부 메모리를 사용해서 정렬하는 것
외부정렬 - 데이터의 크기가 메모리에 올려서 확인하기 힘들 때 사용하는방법
		ex) 분할 정복 / 조금씩 분할 시켜서 내부정렬을 할 수 있는 만큼씩만 가져와서 정렬하고 다시 합병하는 방법

버블정렬 - 한칸씩 앞의 수가 큰지 확인하면서 이동하는데 마지막으로 교환된 곳부터 다시 검사를 시작하면 더 빠를 수 있다.
선택정렬 - 한번 돌면서 가장 작은 값을 찾고 가장 작은 값을 a번 데이터와 바꾸고 a에 1을 더한뒤 반복한다. 입력에 민감하지 않다. 역순으로 정렬된 데이터라면 n^2 알고리즘 중에 가장 빠르다.
삽입정렬 - 순차적으로 진행하면서 현재 선택한 데이터가 왼쪽의 데이터보다 작다면 큰 데이터를 한칸씩 오른쪽으로 밀어주는 연산을 한다. 랜덤한 값을 줬을 때 가장 빠르다.
		현재 잡고 있는 인덱스와 비교하면서 왼쪽으로 검사한다 더 작은 게 나올 때까지 검사하고 나온다면 교환을 한다. 교환을 한번씩만 해준다는 것이다.

거의 정렬된 데이터는 삽입 정렬이 다른 모든 알고리즘들 보다 빠르다.
그래서 우리는 삽입정렬이 빨라질 수 있는 환경을 만들어주고 적용하는 방식을 사용한다.

쉘정렬
gap으로 한번에 여러개씩 옮기고 내부적으로 삽입정렬을 하는 방식
마지막에는 gap을 1로 두고 한번 정렬해봐야한다.
O(n^1.5)

힙정렬
1. 힙 상태로 만든다.  O(n)의 시간이 걸린다
2. 가장 아래에 있는 노드와 루트 노드를 바꾼다.
3. 루트노드 였던 노드를 이미 정렬된 제외된 상태로 둔다.
4. 다운힙을 한다.
5. 2~4를 반복한다.
힙의 높이는 [log2의 n]이다.
힙정렬은 캐시 메모리를 잘 사용하지 못하는 정렬이라 성능이 떨어질 수 있다.
캐시미스가 일어나 성능이 잘 안나온다.

비교정렬은 nlogn보다 빨라지지 않는다.
기수정렬과 계수정렬은 비교하지 않기 때문에 더 빨라질 수 있다.
계수정렬은 데이터의 중복이 많고 종류가 적다면 굉장히 빨라진다. O(n+r) r이 n보다 작다면 사용한다. r이 현저히 작다면 O(n)이라고 볼 수 있다.
기수정렬은 종류가 많을 때 사용하면 좋다. O(k(n+r)) k나 r의 값이 n보다 크지 않을 때 사용한다. k를 키워서 r의 크기를 작게 만든다.

분할 정복 알고리즘은 문제의 크기를 자르고 잘라서 더이상 의미가 없을 때까지 잘라서 사용한다.
삽입정렬이나 피보나치 수의 계산을 부분정렬로 푼다면 부분문제가 계속 커져서 의미가 없다.

합병정렬 두개의 반에서 한명씩 팔씨름 하는것
추가적인 메모리 공간이 필요한 정렬이다.

퀵정렬은 추가적인 메모리 공간이 거의 사용되지 않는다.(재귀함수의 반복)
최대한 반반으로 나누어 지게 만드는게 성능에 도움이 되겠다.
랜덤, 3숫자의 중앙값을 사용하는것
자료가 커지면 커질 수록 피봇을 선정하는게 중요하다.
크기가 작아지면 삽입정렬을 사용한다.

피봇을 선정하고 파티션을 했는데 그러면 다음 피봇을 어디에서 구해야하는가/
small그룹과 large그룹에서 몇번째 숫자가 내가 찾는 숫자인가를 물어볼것이다.


최근접점쌍 찾기
분할 했을 때 사이에 있는 점사이의 길이도 고려해야한다. strip
y좌표기준으로 정렬하고 y좌표의 차이가 분할 된곳에서 찾은 최소 거리 d안에 없다면 반복문에서 break하고 다른 점을 찾는다. 이런식으로 알고리즘을 만들면 7개의 점보다 더 많이 비교할 일이 없을 것이다.
O(nlogn)


효율성 정확성 유한성 수행성
퀵정렬도 추가적인 메모리 공간이 사용되기는 한다.
피봇값을 정하는 방법 - 랜덤, 3개의 숫자의 중앙값을 이용하는 방법
