임의의 데이터를 가지고 정렬을 하기 때문에 
selection정렬은 무작위한 데이터에서 삽입정렬 보다 빠름
	일정한 빠르기를 가지고 있음
삽입정렬은 거의 정렬된 데이터에서 빠르다
	쉘정렬에서 파티션을 나눠놓고 층마다 삽입정렬을 한다.

최댓값을 찾기 위해 최소한 n번은 비교해야한다.

gap을 줄이는 루프
gap개수 만큼 gap안에서 정렬을 하는 루프
주인공을 바꾸는 루프
	gap부터 끝까지 주인공으로 만든다?
주인공을 어디까지 보낼까의 루프
삽입정렬의 루프

쉘정렬을 구현할 수 있어야 겠다.
앞에서부터 1000개만 가져온다
numbers = numbers[:1000]

모듈링
아래의 코드들을 바꾸지 않고 위에 변수 내용만 바꾸는것
                         
파이썬에서 변수이름으로 지정해둔것들 앞뒤로 __를 붙여준다.
print(__name__) -> 내가 어디에서 왔는가


2024-10-18---------------------------------------------------------
알고리즘이란 문제를 해결하기 위한 단계적인 절차(요리법처럼 단계가 있다는 뜻)
어떻게를 고민하는 학문

일반적으로 알고리즘은 수도 코드로 나타낸다.
수도 코드를 가장 많이 쓴다.
플로우 차트 나올거 같다. 코드를 잘모르는 사람에게 설명할 때 좋다.

코드를 잘짜는 사람들이 잘 모르는 사람들에게 이렇게 하면 좋다고 알려주는 것이 알고리즘 기술이다.
순차탐색 - 다 한번씩 돌면서 찾아보는것
(데이터가 정렬되어 있다면)이진탐색 - 반씩 나눠가면서 찾는다. binary search
한붓그리기 - 현재 점으로 돌아오는 사이클이 존재한다면 진행한다. 
		외길이면 진행한다.
미로 찾기 - 오른손 법칙(문제의 본질을 해치지 않는 방법으로 해를 구해야한다.
동전 찾기 - 최소의 양팔저울을 사용해서 값을 찾는다.


주어진 입력에 대해 올바른 해를 구해야한다
유한시간 내에 종료되어야 한다.
알고리즘은 최소 1개 이상의 결과를 가진다.


효율성 수행시간, 메모리 크기, 개발 복잡도
연산횟수를 입력의 크기로 나타내는게 시간복잡도

점근적표기 (빅오 - 상한), (빅세타 - 빅오와 빅오메가를 모두 만족하는 범위), (빅오메가 - 하한)
빅오라고 써져 있어도 빅세타일 수 있으므로 잘 파악해서 풀어보자


n의 값이 크다고 생각될 수 있는 n(0) 이후부터 상수시간이 다른 알고리즘보다 빠르다.
set 상수시간이 걸린다.
set 집합이라고 생각하면 된다.


O(1)
O(logn)
O(n)
O(nlogn)
O(n^2)
O(n^3)
O(n^k)
O(k^n)

내부정렬 컴퓨터의 내부 메모리를 사용해서 정렬 가능한 방법
외부정렬 
정렬알고리즘을 이 기준으로 나눌 수 있어야 한다.


어떤 알고리즘들이 안정적인가
공간복잡도를 요구하는 알고리즘이 있는가

안정적인 정렬을 사용할 거면***************
합병정렬을 사용할거다

버블 - 한칸씩만 앞의 수가 큰가 확인하면서 이동하는데 마지막으로 교환이 일어난곳부터 다시 검사를 하면 조금 더 빨라 질 수 있다.
선택정렬 - 입력에 민감하지 않은 어떤 정렬이 들어와도 시간이 비슷하게 걸린다. 임의의 데이터라면 3개중에 가장 빠르다.
삽입정렬 - 2중 루프를 사용해서 만든다. 
삽입정렬과 선택정렬의 차이 *

거의 정렬된 데이터를 사용하면 삽입정렬이 훨씬 더 빠르다.
우리가 삽입 정렬이 빠를 수 있는 상태를 만들어 놓고 사용하기 때문에 삽입 정렬이 거의 O(n)의 속도를 보여준다.


삽입정렬을 gap으로 많이 씩 옮겨 보자 한게 쉘정렬이다.
gap으로 구간을 정하고 나눈뒤 나눈거 안에서 삽입정렬하고
각각의 1번 인덱스를 다른 곳에 저장하고 2번을 저장하는 식으로 돌고 마지막에는 gap을 1로 두고 정렬을 해봐야 한다.
쉘정렬의 수도코드도 한번 써보자
O(n^1.5)

힙정렬
힙이라는 상태로 만든다.
각노드의 우선순위가 자식 노드보다 높다.
힙의 높이는 log2의 n이다.
다운힙 - logn의 시간이 걸린다. 두자식을 비교해서 더 큰 자식과 나를 비교해서 더 큰수를 부모로 둔다.
어떤 트리를 힙상태로 만드는 방법
오른쪽 트리를 힙상태로 만들고 왼쪽 트리를 힙상태로 만든뒤 나를 다운힙 시켜주면 힙상태가 된다.
자식을 가지고 있는 노드가 정확히 절반이라 첫번째 노드를 힙상태로 만드는게 log(n)이다.
힙 만드는데O(n) 
최선 최악 모두 O(nlogn)의 시간이 걸리지만 잘 안쓴다.

힙정렬은 운영체제의 기능인 캐시 메모리를 잘 사용하지 못하는 정렬이라 이득을 보지 못한다.
캐시미스가 일어나 성능이 잘 안나온다.


비교정렬은 nlogn보다 빨라지지 않지만************
기수정렬, 계수정렬은 비교하지 않기 때문에 더 빨라질 수 있다.
계수정렬은 데이터의 중복이 많고 종류가 적다면 굉장히 빨라진다. O(n+r) r이 n보다 작다면 사용한다. r이 현저히 작다면 O(n)이라고 볼 수 있다.
기수정렬은 종류가 많을 때 사용하면 좋다. O(k(n+r)) k나 r의 값이 n보다 크지 않을 때 사용한다. k를 키워서 r의 크기를 작게 만든다.


분할 정복 알고리즘 문제의 크기를 자르고 잘라서 더이상 의미가 없을 때 까지 잘라서 사용한다.
삽입정렬이나 피보나치 수의 계산을 부분정렬로 푼다면 부분문제가 계속 커져서 의미가 없다.

합병정렬 두개의 반에서 한명씩 팔씨름 하는것
추가적인 메모리 공간이 필요한 정렬이다.

퀵정렬은 추가적인 메모리 공간이 거의 사용되지 않는다.(재귀함수의 반복)
최대한 반반으로 나누어 지게 만드는게 성능에 도움이 되겠다.
랜덤, 3숫자의 중앙값을 사용하는것
자료가 커지면 커질 수록 피봇을 선정하는게 중요하다.
크기가 작아지면 삽입정렬을 사용한다.

피봇을 선정하고 파티션을 했는데 그러면 다음 피봇을 어디에서 구해야하는가/
small그룹과 large그룹에서 몇번째 숫자가 내가 찾는 숫자인가를 물어볼것이다.


최근접점쌍 찾기
분할 했을 때 사이에 있는 점사이의 길이도 고려해야한다. strip
y좌표기준으로 정렬하고 y좌표의 차이가 분할 된곳에서 찾은 최소 거리 d안에 없다면 반복문에서 break하고 다른 점을 찾는다. 이런식으로 알고리즘을 만들면 7개의 점보다 더 많이 비교할 일이 없을 것이다.
O(nlogn)



어디까지 진행되었고 다음 상태가 어떻게 될것인지를 볼것이다.
수도 코드 사용방법 알아야겠고


greedy 알고리즘 - 항상 해를 구할 수는 없다.
다른 알고리즘으로 풀면 해가 나오지 않기 때문에 근사 값이라도알아보자는 느낌으로
























