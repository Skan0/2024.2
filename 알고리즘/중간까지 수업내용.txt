알고리즘
알고리즘은 어떻게에 대한 답이다
이런식으로 프로그램을 짜면된다고 알려주는 책

올바른해
컴퓨터에서 수행가능
유한시간내에 수행 가능해야함
보통은 시간 복잡도가 적은 알고리즘이 우선시 된다
개발 복잡도 
기본적인 연산 횟수를 입력크기의 함수로 나타낸다
최악의 경우를 분석하는게 알고리즘의 성능이 된다.
언제 대부분의 경우가 아니고 평균경우를 이야기하는지**
 -> quick sort 평균nlogn 최악n^2

시간적 복잡도는 점근적 표기를 사용


유클리드의 최대공약수 구하는 방법
두수를 서로 빼서 남은 수와 작은 수의 최대공약수와 구하고자하는 최대공약수가 같다.


빅오 표기법
특정 n이상 부터는 절대로 상하가 바뀔리가 없다

점근적 상한
앞에 상수를 곱하는경우

빅오메가
점근적하한
2/1이나 3/1등을 곱하는경우 

빅세타 최고 차수 항만을 취한뒤 그항의 계수를 제거하여
학계에서 얘기하는 빅오와 
업계에서 사용하는 빅오가 다르다 


진정한 빅오를 얘기하는것이라면 가장 빠른것과 비교할 때 빠른게 이기지만
빅 세타를 얘기한다면 그렇지 않다??
2024-09-06

python의 generator 
print(" ", end" ")

java swift 원소들 맨뒤에도 컴마를 붙여도 좋다.
슬라이싱은 이상 : 미만
randint를 사용할 때만 이상 : 이하

dictionary
hash값을 이용해서 데이터를 빨리 찾을 때 사용한다.
key값과 value값으로 이루어져 있다.

서로 개수가 맞는 tuple과 변수 들이 있다면 
수학 과학과 같이 종류가 많읂 곳들에 넣기 좋다.
튜플은 오직 읽기만 할 수 있다.

함수 사용
- 인수분해(인자를 바꿔서 내놓자 바뀔 )
- 메인 함수의 간편화 추상화
모두 지역변수라 함수가 끄타면
global 변수라고 지정하고 사용하면 사용가능하다.

tuple을 인자로 사용할 때 tuple 앞에 *를 붙여주면 튜플이 펼쳐져서 안에있는 원소들이 인자로 다 들어간다
tuple로 함수에서 여러가지 값을 리턴 받을 수 있지만 
tuple이 없는 언어에서는 포인터로 두개이상의 값을 리턴한다.

객체를 생성할 때 new라는 키워드를 사용하지 않는다.
함수 호출과 문법이 동일하다.


flags = [ True, False, True ]
for flag in flags:
  todo = Hello if flag else func
  obj = todo() # 함수 호출과 객체 생성이 동일한 문법 구조에 의해 일어난다
  print('flag 값은:', flag, '이번에 얻은 것은:', obj)

todo가 hello면 객체를 생성하고 func면 함수를 실행한다.
변수의 형태가 정해지지 않았다는게 이런일을 가능하게 한다.


def __init__(self): -> 생성자
	self.(클래스로 생성되는 객체가 모두 가지고 있었으면 하는 상태를 넣어주는 곳)

# 다형성 같은 명령을 내려도 본인이 해야할 각자의 일을 하는것

fstring 
변수 이름을 바로 출력해주는 방법이 있다 =을 뒤에 붙이면 된다.


기수정렬
데이터의 최댓값과 최솟값의 차이가 크지 않을 때 사용하면 적합하다
어떤 데이터가 몇개 있는지 확인하고 데이터를 정렬해서 저장할 배열에 이 데이터값이 몇번에 들어가야 하는가 적어두고 넣으면 하나씩 줄인다.

계수정렬
각 자릿수를 기수정렬로 정렬하고
다음 자릿수를 정렬하는 식으로 최종 정렬시킨다.

count정렬
n개의 갯수를 세는 횟수 한번
루프가 1회 수행될 때 n개의 숫자의 i자리 수를 읽으며 r개로 분류하여 개수를 세고 그 결과에 따라 숫자가 이동하므로 O(n+r)시간 소요 
r이 n보다 크지 않다면 O(n)으로 봐도 무관
알파뱃으로 이루어진 단어와 같은것들을 정렬할 때 좋다.
MSD큰 데이터 부터 정렬
LSD

	내부정렬 internal sort
입력의 크기가 주기억 장치의 공간보다 크지않은 경우에 수행되는 정렬
버블정렬, 선택정렬, 삽입정렬, 합병정렬, 퀵정렬, 힙정렬, 쉘정렬, 기수정렬, 이중 피봇 퀵정렬, 

	외부정렬 external sort
입력의 크기가 주기억장치 공간보다 큰 경우에 보조기억 장치에 다시 저장하는 과정을 반복
다방향 합병, 다단계 합병

안정적인 정렬인가 아닌가를 알아두는게 좋다.
최악의 경우를 보는게 대부분이지만 최악의 경우를 보지 않는 경우도 있다.s

	버블 정렬
왼쪽이 오른쪽보다 크다? 자리 바꿈을 반복하는것

	선택 정렬
최댓값을 찾는 게산을 n번 하는것
일정한 시간 복잡도
입력에 민감하지 않음
원소간의 자리바꿈횟수가 최소인 정렬

	삽입 정렬
배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고
정렬되지 않은 부분에서 정렬된 부분의 알맞은 위치로 넣어주는것
거의 정렬된 입력에 대해서 다른 정렬알고리즘 보다 빠르다
입력의 크기가 작을 때 매우 좋은 성능을 보임
 
	쉘정렬
한칸씩 많이 정렬 해보자 하는게 쉘정렬
배열 뒷부분의 작은 숫자를 빠르게 앞으로 이동
gap의 크기를 정해서 작은 크기의 그룹으로 나누고 이것을 삽입정렬
그리고 정렬된 그룹의 1번 인덱스 끼리 연속되게 놓고
2번 인덱스 끼리 연속되게 뒤에 붙이는 식으로 진행한다.
이렇게 하면 대체로 큰수들은 뒤로 모이고
대체로 작은 수들은 앞으로 모인다.
남은 숫자들에 대해서 삽입정렬을 한다
삽입정렬은 약간정렬되어있는 데이터에서 빠르다.
쉘 정렬의 시간복잡도는 gap을 얼마로 잘 놓느냐에 따라 바뀐다.

	Binary Heap 이진 힙
힙 조건을 만족하는 완전 이진 트리
최대 힙 부모가 자식보다 항상 값이 큰 트리
최소 힙 부모가 자식보다 항상 값이 작은 트리


2024-09-27
힙정렬 코드 보고 제작하기

배열로 저장되는 자료는 완전이진트리로 표현할 수 있다.
루트인덱스

왼쪽에 자식이 있는가
오른쪽에 자식이 있는가
둘이 크기 비교후 부모와 비교
이를 재귀 호출 한다.
root인덱스가 0일 때 
왼쪽 child = i * 2 +1
오른쪽 child = i * 2 + 2

down heap에 대한 내용

아래부터 down heap으로 만들어두고 root까지 올라가야 한다.
완전이진트리는 항상 절반이 자식이 없고 절반은 자식이 있다.
첫번째로 검사할 인덱스가 count // 2 - 1이다.

n번 반복한다.
down힙이 완성되었다면
이제 힙정렬이 진행된다.
root에서 하나씩 빼서 배열의 끝에 있는 노드와 교환한다.
바꾸고 다시 다운힙을 한다.

비교정렬의 하한 = nlogn
비교정렬이 아닌 빠른 정렬 알고리즘(특정조건이 필요함)
계수 정렬, 기수 정렬

개수를 앞에서 부터 더해서 위치를 나타내줌
인덱스 -1의 위치에 값을 넣고 위치를 하나 줄인다.

n+r(데이터의 종류)만큼의 시간이 걸림 **
데이터의 종류가 적을 수록 효율적인 알고리즘이 된다.
r이 n과 비슷하거나 작을 때 사용하면 좋다.
안정적인 정렬이다.
원래의 순서를 지키면서 정렬이 된다.

기수정렬
자릿수 별로 계수정렬을 해준다.
뒤에서 부터 뽑아서 뒤에서부터 넣기 때문에 순서가 유지 되어서 다른 자릿수 정렬할 때도 순서가 유지 된다.
(n + r ) * k **

26개의 알파벳과 빈공간을 포함해서 27진법이 된다.
Lsd 
Msd
알파벳정렬은 기수정렬과 같은 방법으로 한다. 하지만 순서는 알파벳 앞에서 부터 검사한다.
내가 정렬해야하는 데이터의 특성을 알고 추가적인 수정이 들어가면 더 좋은 알고리즘이 될 수 있다.


2024-09-30
분할정복 알고리즘
분할한 입력에 대하여 동일한 알고리즘을 적용하여 해를 계산
이들의 해를 취합하여 해결하는 알고리즘

3개로 쪼갤 때 문제의 크기는 점차 반으로 쪼개지더라
log2(n)번 분할 할 것이다.

분할되는 문제의 수와 크기
퀵정렬 - 부분문제의 크기가 일정하지 않다.
분할했을 때 문제의 크기가 반정도의 크기로 쪼개질 때 사용한다.



합병정렬
(빠른편에 속하는 알고리즘 / 안정적인 알고리즘이다)
입력이 2개의 문제로 분할되고 부분문제의 크기가 1/2로 감소하는 분할 정복 알고리즘

n개의 문제들을 n/2개씩 2개의 부분 문제로 분할

가운데값을 정하고 가운데 까지를 정렬하고 나머지 절반을 정렬한다.
1번과 2번 배열이라고 한다면 배열의 앞에서 부터 작은 데이터들을 뽑아서 결과 배열에 저장한다.

원소가 하나가 될때까지 나누고 나누고 나눈다.
mergesort L (insertionsort - below 8)
mergesort R 
merge

합병하는 시간 -> n+n
한층마다 n번씩 비교한다.
log2(n)개의 층수

nlogn의 알고리즘
O(n)만큼의 메모리가 별도의 메모리가 필요함


퀵정렬
(가장 빠름 / 안정적이지 않다.)
정복후 분할하는 느낌

합병이라는 과정이 없다.
어디에서 분할할지 알 수 없다.

파티션 (피봇정하기)
왼쪽 qsort
오른쪽 qsort

피봇을 구하는 방법
랜덤하게 설정
3숫자의 중앙값으로 선정하는 방법 - 숫자를 3개뽑아 3개중에 가운데값을 사용한다.

중앙값의 중앙값 데이터의 양이 엄~청나게 많을 때


선택문제 SelectionSort

퀵정렬
파티션 생성
왼쪽 퀵정렬
오른쪽 퀵정렬
의 형태로 반복하면서
파티션을 선택했을 때
퀵정렬을 할 원소의 개수가 삽입정렬을 해도 될 정도 일 때
삽입정렬을  한다.

selection(A, left, right, K)
A[left] ~ A[right]에서 k번째 작은 원소

피봇을 랜덤하게 선택하고
0과 피봇의 위치를 바꾼뒤
1부터 피봇보다 큰수를 찾았다면
끝에서부터 피봇보다 작은수를 찾아서 둘이 위치를 교환해준다.

최근접점 쌍찾기 - 여러가지 점 중에서  서로의 거리가 가장 짧은 점 두개를 찾는것
분할정복을 이용
하지만  분할할 때 중간 영역을 고려해야한다.

brute force 대충하겠다.
일일히 다 찾아보겠다
n*(n-1)/2전체 비교해야하는 횟수
분할 시켰다면 분할된 부분에서 결과를 구하고 

왼쪽이나 오른쪽에서  구한 가장 작은 거리의 x좌표  차이보다 작은 간격으로 있는 분할된 지점을 기준으로 나뉜점들을 확인해봐야한다.
왼쪽 그룹에 가장 오른쪽에 있는 점에서 가장작은 거리만큼 왼쪽, 오른쪽x 좌표안에 있는녀석들을 모은다.
이것들 중에서도 전부 비교하지 않고
y좌표를 오름차순을로 정렬해서 y좌표 차이가 가장작은 거리보다 크다면 나머지를 비교하지 않는다.
반복문에ㅔ서 break를 사용할 수 있다.

처음부터  y좌표로도 정렬해둔 배열을 생성
strip사이에 있는 점들을 y좌표로 정렬해둔 배열에서 가져와서 정렬된 데이터를 사용한다.

왼쪽 그룹에 가장 오른쪽에 있는 점
오른쪽 그룹에 가장 왼쪽에 있는 점
을 비교한다.

x좌표로 점들을 정렬해서 배열을 만듦
y좌표로 점들을 정렬해서 배열을 만듦(매번 분할된  점들을 y좌표로 정렬하는게 아닌 정렬된 자료에서 데이터를 가져오는게 더 효율적이다.)
mergesort처럼 원소가 2나 3이 될 때까지  분할을 하면서 거리를 계산

float('inf')


2024-10-11
각언어에서 정렬을 사용하는 방법에 대해 알아보자
c언어 qsort








